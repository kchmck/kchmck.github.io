var searchIndex = {};
searchIndex["collect_slice"] = {"doc":"Collect an iterator into a slice.","items":[[8,"CollectSlice","collect_slice","An iterator that can collect into a slice.",null,null],[10,"collect_slice","","Loop through the iterator, sequentially writing items into the given slice until either the iterator runs out of items or the slice fills up.",0,null],[11,"collect_slice_fill","","Perform `collect_slice()` and panic if iterator yielded too few items to fill the slice.",0,null],[11,"collect_slice_exhaust","","Perform `collect_slice()` and panic if the slice was too small to hold all the items.",0,null],[11,"collect_slice_checked","","Perform `collect_slice()` and panic if there weren't enough items to fill up the slice or the slice was too small to hold all the items.",0,null]],"paths":[[8,"CollectSlice"]]};
searchIndex["imbe"] = {"doc":"Decode the Improved Multi-Band Excitation (IMBE) digital voice codec.","items":[[0,"allocs","imbe","Bit allocations for quantized amplitudes.",null,null],[5,"allocs","imbe::allocs","Retrieve the set of quantized amplitude bit allocations Bm and max(Bm) for the given harmonics parameter L.",null,null],[0,"coefs","imbe","Higher order DCT coefficients.",null,null],[3,"Coefficients","imbe::coefs","Higher order DCT coefficients vector Tl, 1 ≤ l ≤ L.",null,null],[11,"new","","Create a new `Coefficients` vector from the given gains Gm, quantized amplitudes bm, and frame parameters.",0,{"inputs":[{"name":"gains"},{"name":"quantizedamplitudes"},{"name":"baseparams"}],"output":{"name":"coefficients"}}],[11,"get","","Retrieve Tl, 1 ≤ l ≤ L + 1.",0,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"f32"}}],[0,"consts","imbe","Constants used in the codec.",null,null],[17,"SAMPLE_RATE","imbe::consts","Audio samples per second",null,null],[17,"SAMPLES_PER_FRAME","","Samples per voiced/unvoiced frame",null,null],[17,"MIN_HARMONICS","","Number of harmonics L when the fundamental frequency ω0 is maximum.",null,null],[17,"MAX_HARMONICS","","Number of harmonics L when the fundamental frequency ω0 is minimum.",null,null],[17,"NUM_HARMONICS","","Number of discrete values that exist for the harmonics parameter.",null,null],[17,"MAX_QUANTIZED_AMPS","","Maximum number of quantized amplitudes.",null,null],[0,"decode","imbe","Decode IMBE frames into an audio signal.",null,null],[3,"ImbeDecoder","imbe::decode","Decodes a stream of IMBE frames.",null,null],[11,"new","","Create a new `ImbeDecoder` in the default state.",1,{"inputs":[],"output":{"name":"imbedecoder"}}],[11,"decode","","Decode the given frame into the given audio sample buffer.",1,{"inputs":[{"name":"self"},{"name":"receivedframe"},{"name":"audiobuf"}],"output":null}],[0,"descramble","imbe","Initial descrambling of prioritized chunks.",null,null],[3,"QuantizedAmplitudes","imbe::descramble","Reconstructs quantized amplitudes b3, ..., bL+1.",null,null],[3,"VoiceDecisions","","Tracks harmonic voiced/unvoiced decisions.",null,null],[4,"Bootstrap","","Decodes the bootstrap value b0.",null,null],[13,"Period","","Frame contains voiced/unvoiced data derived from enclosed b0 parameter.",2,null],[13,"Silence","","Frame is silence.",2,null],[13,"Invalid","","Invalid b0 value was detected.",2,null],[5,"descramble","","Descramble the given prioritized chunks ui into the underlying quantized amplitudes bm, voiced/unvoiced decisions vl, and initial gain index b2.",null,null],[11,"clone","","",2,{"inputs":[{"name":"self"}],"output":{"name":"bootstrap"}}],[11,"new","","Parse a `Bootstrap` value from the given chunks.",2,{"inputs":[{"name":"chunks"}],"output":{"name":"bootstrap"}}],[11,"get","","Retrieve the quantized amplitude bm, 3 ≤ m ≤ L + 1.",3,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"u32"}}],[11,"clone","","",4,{"inputs":[{"name":"self"}],"output":{"name":"voicedecisions"}}],[11,"new","","Create a new `VoiceDecisions` from the given band voiced/unvoiced bitmap, b1, and frame parameters.",4,{"inputs":[{"name":"u32"},{"name":"baseparams"}],"output":{"name":"voicedecisions"}}],[11,"force_voiced","","Force the given harmonic to be voiced.",4,{"inputs":[{"name":"self"},{"name":"usize"}],"output":null}],[11,"unvoiced_count","","Compute the number of unvoiced spectral amplitudes/harmonics, Luv.",4,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"is_voiced","","Check if the given harmonic is voiced.",4,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"bool"}}],[11,"default","","Create a new `VoiceDecisions` in default state.",4,{"inputs":[],"output":{"name":"self"}}],[0,"enhance","imbe","Frame repeat/muting, spectral amplitude enhancement, and adaptive smoothing.",null,null],[3,"EnhanceErrors","imbe::enhance","Values derived from error correction decoding.",null,null],[12,"total","","Total number of errors corrected in the current frame, ϵT [p45].",5,null],[12,"rate","","Error rate tracking term, ϵR [p45].",5,null],[12,"golay_init","","Errors corrected in first (u0) Golay-coded chunk, ϵ0.",5,null],[12,"hamming_init","","Errors corrected in first (u4) Hamming-coded chunk, ϵ4.",5,null],[3,"FrameEnergy","","Energy-related parameters for a voice frame.",null,null],[12,"energy","","Spectral amplitude energy, RM0.",6,null],[12,"scaled","","Scaled energy value, RM1.",6,null],[12,"tracking","","Moving average energy tracker, SE.",6,null],[3,"EnhancedSpectrals","","Enhanced spectral amplitudes, \"overbar\" Ml, are derived from the decoded spectral amplitudes, \"tilde\" Ml.",null,null],[5,"amp_thresh","","Compute the spectral amplitude threshold τM used in adaptive smoothing from the given error characteristics and previous amplitude threshold.",null,{"inputs":[{"name":"enhanceerrors"},{"name":"f32"}],"output":{"name":"f32"}}],[5,"smooth","","Smooth the given enhanced spectral amplitudes Ml and voiced/unvoiced decisions vl based on the given error characteristics, current frame energy, and spectral amplitude threshold τM for the current frame.",null,{"inputs":[{"name":"enhancedspectrals"},{"name":"voicedecisions"},{"name":"enhanceerrors"},{"name":"frameenergy"},{"name":"f32"}],"output":null}],[5,"should_repeat","","Check whether the current frame should be discarded and the previous repeated based on the given error characteristics of the current frame.",null,{"inputs":[{"name":"enhanceerrors"}],"output":{"name":"bool"}}],[5,"should_mute","","Check if the current frame should be discarded and replaced with silence/comfort noise based on the given error characteristics of the current frame.",null,{"inputs":[{"name":"enhanceerrors"}],"output":{"name":"bool"}}],[11,"new","","Create a new `EnhanceErrors` from the errors corrected in the current frame, ϵi, and the previous frame's ϵR value.",5,{"inputs":[{"name":"errors"},{"name":"f32"}],"output":{"name":"enhanceerrors"}}],[11,"new","","Create a new `FrameEnergy` from the given spectral amplitudes Ml, previous frame energy values, and current frame parameters.",6,{"inputs":[{"name":"spectrals"},{"name":"frameenergy"},{"name":"baseparams"}],"output":{"name":"frameenergy"}}],[11,"default","","Create a new `FrameEnergy` with default initial values.",6,{"inputs":[],"output":{"name":"frameenergy"}}],[11,"clone","","",7,{"inputs":[{"name":"self"}],"output":{"name":"enhancedspectrals"}}],[11,"new","","Create a new `EnhancedSpectrals` from the given base spectral amplitudes Ml and current frame energy values and parameters.",7,{"inputs":[{"name":"spectrals"},{"name":"frameenergy"},{"name":"baseparams"}],"output":{"name":"enhancedspectrals"}}],[11,"get","","Retrieve the enhanced spectral amplitude Ml, 1 ≤ l ≤ L.",7,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"f32"}}],[11,"deref","","",7,null],[11,"deref_mut","","",7,null],[11,"default","","Create a new `EnhancedSpectrals` with default initial values.",7,{"inputs":[],"output":{"name":"enhancedspectrals"}}],[0,"frame","imbe","Received IMBE voice frame.",null,null],[3,"ReceivedFrame","imbe::frame","A received IMBE voice frame.",null,null],[12,"chunks","","Prioritized bit vector chunks, u0, ..., u7.",8,null],[12,"errors","","Error correction counts, ϵ0, ..., ϵ6.",8,null],[6,"Chunks","","Represents the bit vectors u0, ..., u7, in that order.",null,null],[6,"Errors","","Represents the number of detected Hamming/Golay bit errors, ϵ0, ..., ϵ6, corresponding to the chunks u0, ..., u6.",null,null],[6,"AudioBuf","","Audio samples in a decoded voice frame.",null,null],[11,"new","","Create a new `ReceivedFrame` from the given chunks u0, ..., u7 and error counts ϵ0, ..., ϵ6.",8,{"inputs":[{"name":"chunks"},{"name":"errors"}],"output":{"name":"receivedframe"}}],[0,"gain","imbe","Quantized gain vector.",null,null],[3,"Gains","imbe::gain","The gain vector Gm, 1 ≤ m ≤ 6, gives a coarse envelope for the voice frame.",null,null],[11,"new","","Create a new `Gains` vector from the given initial gain index b2, quantized amplitudes bm, 3 ≤ m ≤ L + 1, and frame parameters.",9,{"inputs":[{"name":"usize"},{"name":"quantizedamplitudes"},{"name":"baseparams"}],"output":{"name":"gains"}}],[11,"idct","","Compute the inverse DCT Ri, 1 ≤ i ≤ 6.",9,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"f32"}}],[0,"params","imbe","Frame parameters.",null,null],[3,"BaseParams","imbe::params","Basic parameters of the current frame.",null,null],[12,"fundamental","","Fundamental frequency ω0 the frame is derived from.",10,null],[12,"harmonics","","Number of harmonics L of the fundamental frequency present in the frame.",10,null],[12,"bands","","Number of frequency bands K in the frame, each of which is classified as either voiced or unvoiced.",10,null],[11,"clone","","",10,{"inputs":[{"name":"self"}],"output":{"name":"baseparams"}}],[11,"new","","Create a new `BaseParams` from the given period b0.",10,{"inputs":[{"name":"u8"}],"output":{"name":"baseparams"}}],[11,"default","","Create a new `BaseParams` with initial default values.",10,{"inputs":[],"output":{"name":"baseparams"}}],[0,"prev","imbe","Previous frame saved parameters.",null,null],[3,"PrevFrame","imbe::prev","Various parameters saved from the previous frame, used when constructing the current frame.",null,null],[12,"params","","",11,null],[12,"spectrals","","",11,null],[12,"enhanced","","",11,null],[12,"voice","","",11,null],[12,"err_rate","","",11,null],[12,"energy","","",11,null],[12,"amp_thresh","","",11,null],[12,"unvoiced","","",11,null],[12,"phase_base","","",11,null],[12,"phase","","",11,null],[11,"default","","Create a new `PrevFrame` suitable for decoding the very first IMBE frame in a stream.",11,{"inputs":[],"output":{"name":"prevframe"}}],[0,"scan","imbe","Scanning procedure used in descrambling.",null,null],[3,"ScanSep","imbe::scan","Decodes voiced/unvoiced decisions and the quantized gain index fragment from prioritized chunks.",null,null],[12,"voiced","","Voiced/Unvoiced Boolean bit vector, b1 [p25].",12,null],[12,"idx_part","","Bits 1 and 2 of the 6-bit quantized gain index, b2 [p30].",12,null],[12,"scanned","","Chunk of some bm used in the scanning procedure [p39].",12,null],[3,"ScanChunks","","Iterates over the chunks covered in the scanning procedure [p39].",null,null],[3,"ScanBits","","Sequentially extracts the bits scanned into prioritized chunks.",null,null],[11,"clone","","",12,{"inputs":[{"name":"self"}],"output":{"name":"scansep"}}],[11,"new","","Create a new `ScanSep` decoder from the given chunks and frame parameters.",12,{"inputs":[{"name":"chunks"},{"name":"baseparams"}],"output":{"name":"scansep"}}],[11,"new","","Create a new `ScanChunks` iterator over the given chunks.",13,{"inputs":[{"name":"chunks"},{"name":"u32"},{"name":"baseparams"}],"output":{"name":"self"}}],[11,"next","","",13,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"new","","Create a new `ScanBits` iterator over the given scan chunks.",14,{"inputs":[{"name":"scanchunks"}],"output":{"name":"self"}}],[11,"next","","",14,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[0,"spectral","imbe","Spectral amplitudes.",null,null],[3,"Spectrals","imbe::spectral","Spectral amplitudes Ml, 1 ≤ l ≤ L, measure the spectral envelope of the voiced/unvoiced signal spectrum.",null,null],[11,"clone","","",15,{"inputs":[{"name":"self"}],"output":{"name":"spectrals"}}],[11,"new","","Create a new `Spectrals` from the given DCT coefficients vector Tl and current/previous frame parameters.",15,{"inputs":[{"name":"coefficients"},{"name":"baseparams"},{"name":"prevframe"}],"output":{"name":"spectrals"}}],[11,"get","","Retrieve the spectral amplitude Ml for the given l.",15,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"f32"}}],[11,"deref","","",15,null],[11,"default","","Construct the default set of spectral amplitudes.",15,{"inputs":[],"output":{"name":"spectrals"}}],[0,"unvoiced","imbe","Unvoiced spectrum synthesis.",null,null],[3,"UnvoicedDft","imbe::unvoiced","Constructs unvoiced DFT/IDFT.",null,null],[3,"Unvoiced","","Synthesizes unvoiced spectrum signal suv(n).",null,null],[11,"new","","Construct a new `UnvoicedDft` from the given frame parameters and noise generator.",16,{"inputs":[{"name":"baseparams"},{"name":"voicedecisions"},{"name":"enhancedspectrals"},{"name":"r"}],"output":{"name":"self"}}],[11,"idft","","Compute the IDFT uw(n) at the given point n.",16,{"inputs":[{"name":"self"},{"name":"isize"}],"output":{"name":"f32"}}],[11,"default","","Create a new `UnvoicedDft` in the default state.",16,{"inputs":[],"output":{"name":"self"}}],[11,"new","","Create a new `Unvoiced` from the given unvoiced spectrums of the current and previous frames.",17,{"inputs":[{"name":"unvoiceddft"},{"name":"unvoiceddft"}],"output":{"name":"self"}}],[11,"get","","Compute the unvoiced signal sample suv(n) for the given n, 0 ≤ n < N.",17,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"f32"}}],[0,"voiced","imbe","Voiced spectrum synthesis.",null,null],[3,"PhaseBase","imbe::voiced","Computes the base phase offsets Ψl.",null,null],[3,"Phase","","Computes the random phase terms Φl.",null,null],[3,"Voiced","","Synthesizes voiced spectrum signal sv(n).",null,null],[11,"new","","Create a new `PhaseBase` from the given current and previous frame parameters.",18,{"inputs":[{"name":"baseparams"},{"name":"prevframe"}],"output":{"name":"self"}}],[11,"get","","Retrieve the phase term Ψl, 1 ≤ l ≤ 56.",18,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"f32"}}],[11,"default","","Create a new `PhaseBase` in the default state.",18,{"inputs":[],"output":{"name":"self"}}],[11,"new","","Create a new `Phase` building on the given base phase terms.",19,{"inputs":[{"name":"phasebase"},{"name":"baseparams"},{"name":"prevframe"},{"name":"voicedecisions"},{"name":"r"}],"output":{"name":"self"}}],[11,"get","","Retrieve the phase term Φl, 1 ≤ l ≤ 56.",19,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"f32"}}],[11,"default","","Create a new `Phase` in the default state.",19,{"inputs":[],"output":{"name":"self"}}],[11,"new","","",20,{"inputs":[{"name":"baseparams"},{"name":"prevframe"},{"name":"phase"},{"name":"enhancedspectrals"},{"name":"voicedecisions"}],"output":{"name":"self"}}],[11,"get","","Compute the voiced signal sample sv(n) for the given sample n, 0 ≤ n < 160.",20,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"f32"}}],[0,"window","imbe","Signal windowing.",null,null],[3,"Window","imbe::window","Wraps a set of window coefficients and remaps the center coefficient to index 0.",null,null],[5,"synthesis","","Retrieve the speech synthesis window ws.",null,{"inputs":[],"output":{"name":"window"}}],[17,"ENERGY_SYNTHESIS","","Energy of speech synthesis window.",null,null],[11,"new","","Create a new `Window` with the given coefficients.",21,null],[11,"get","","Retrieve the coefficient w(n) for the given n.",21,{"inputs":[{"name":"self"},{"name":"isize"}],"output":{"name":"f32"}}]],"paths":[[3,"Coefficients"],[3,"ImbeDecoder"],[4,"Bootstrap"],[3,"QuantizedAmplitudes"],[3,"VoiceDecisions"],[3,"EnhanceErrors"],[3,"FrameEnergy"],[3,"EnhancedSpectrals"],[3,"ReceivedFrame"],[3,"Gains"],[3,"BaseParams"],[3,"PrevFrame"],[3,"ScanSep"],[3,"ScanChunks"],[3,"ScanBits"],[3,"Spectrals"],[3,"UnvoicedDft"],[3,"Unvoiced"],[3,"PhaseBase"],[3,"Phase"],[3,"Voiced"],[3,"Window"]]};
searchIndex["iq_osc"] = {"doc":"I/Q oscillator without trig function calls.","items":[[3,"IQOsc","iq_osc","Quadrature oscillator with current phase Φ(t) and phase step ω.",null,null],[11,"clone","","",0,{"inputs":[{"name":"self"}],"output":{"name":"iqosc"}}],[11,"new","","Create a new `IQOsc` starting at the given initial phase θ0 (in radians) and with the given phase step ω (in radians).",0,{"inputs":[{"name":"t"},{"name":"t"}],"output":{"name":"self"}}],[11,"set_step","","Change the phase step to the given ω (in radians).",0,{"inputs":[{"name":"self"},{"name":"t"}],"output":null}],[11,"set_phase","","Change the current phase to the given θ (in radians).",0,{"inputs":[{"name":"self"},{"name":"t"}],"output":null}],[11,"next","","Step the phase to Φ(t+1) and return (sin Φ(t), cos Φ(t)).",0,null]],"paths":[[3,"IQOsc"]]};
searchIndex["p25"] = {"doc":"Implements the Project 25 (P25) air interface radio protocol, including baseband frame synchronization, symbol decoding, error correction coding, and packet reconstuction.","items":[[0,"baseband","p25","Sychronization and symbol encoding/decoding of C4FM signal used by P25.",null,null],[0,"decode","p25::baseband","Utilities for decoding a C4FM signal into symbols.",null,null],[3,"Decoder","p25::baseband::decode","Decodes symbol from sample at each symbol instant.",null,null],[3,"Decider","","Decides which symbol a sample represents with a threshold method.",null,null],[11,"clone","","",0,{"inputs":[{"name":"self"}],"output":{"name":"decoder"}}],[11,"new","","Create a new `Decoder` with the given symbol decider, initialized to decode the first symbol after the frame sync has been detected.",0,{"inputs":[{"name":"decider"}],"output":{"name":"decoder"}}],[11,"feed","","Examine the given sample and, based on the symbol clock, decode it into a symbol or do nothing.",0,{"inputs":[{"name":"self"},{"name":"f32"}],"output":{"generics":["dibit"],"name":"option"}}],[11,"clone","","",1,{"inputs":[{"name":"self"}],"output":{"name":"decider"}}],[11,"new","","Create a new Decider with the given positive threshold, mid threshold, and negative threshold.",1,{"inputs":[{"name":"f32"},{"name":"f32"},{"name":"f32"}],"output":{"name":"decider"}}],[11,"decide","","Decide which symbol the given sample looks closest to.",1,{"inputs":[{"name":"self"},{"name":"f32"}],"output":{"name":"dibit"}}],[0,"encode","p25::baseband","Utilities for encoding symbols as a C4FM signal.",null,null],[3,"C4fmImpulses","p25::baseband::encode","Yields a series of scaled impulses vs time corresponding to given dibits.",null,null],[3,"C4fmDeviationDibits","","Generates the alternating series of dibits used for the C4FM deviation test. The resulting filtered waveform approximates a 1200Hz sine wave.",null,null],[11,"new","","Construct a new `C4fmImpulses<T>` from the given source and sample rate.",2,{"inputs":[{"name":"t"}],"output":{"name":"c4fmimpulses"}}],[11,"next","","",2,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"new","","Construct a new `C4fmDeviationDibits`.",3,{"inputs":[],"output":{"name":"c4fmdeviationdibits"}}],[11,"next","","",3,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[0,"sync","p25::baseband","Utilities for detecting the frame synchronization sequence and extracting symbol decoding thresholds from it.",null,null],[3,"SyncCorrelator","p25::baseband::sync","Continuously cross-correlates input signal with frame sync fingerprint.",null,null],[3,"SymbolThresholds","","Computes symbol decision thresholds from sync sequences.",null,null],[3,"SyncDetector","","State machine that detects a peak power above an instantaneous threshold. Once the power goes above the threshold, further thresholds are ignored and power is tracked until it peaks.",null,null],[3,"SyncFingerprint","","",null,null],[5,"sync_threshold","","Compute the sync correlator detection threshold for the given current signal power.",null,{"inputs":[{"name":"f32"}],"output":{"name":"f32"}}],[17,"SYNC_GENERATOR","","Symbols that make up the frame sync fingerprint.",null,null],[11,"new","","Create a new `SyncCorrelator` with default state.",4,{"inputs":[],"output":{"name":"synccorrelator"}}],[11,"feed","","Cross-correlate with the given sample and return the current correlation power and signal power within the correlation history.",4,null],[11,"history","","Retrieve the sequence of samples that make up the current sync sequence.",4,null],[11,"new","","Create a new `SymbolThresholds` with default state.",5,{"inputs":[],"output":{"name":"self"}}],[11,"thresholds","","Calculate `(upper, mid, lower)` thresholds for symbol decoding from the given sync fingerprint samples.",5,null],[11,"clone","","",6,{"inputs":[{"name":"self"}],"output":{"name":"syncdetector"}}],[11,"fmt","","",6,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Create a new `SyncDetector` in the default state.",6,{"inputs":[],"output":{"name":"syncdetector"}}],[11,"detect","","Consider the given power related to the given instantaneous power threshold. Return `true` if the power peaked above threshold in the previous sample and `false` otherwise.",6,{"inputs":[{"name":"self"},{"name":"f32"},{"name":"f32"}],"output":{"name":"bool"}}],[11,"size","","",7,{"inputs":[],"output":{"name":"usize"}}],[11,"coefs","","",7,null],[11,"default","","",7,{"inputs":[],"output":{"name":"self"}}],[11,"deref","","",7,null],[11,"deref_mut","","",7,null],[0,"bits","p25","Dibits, tribits, and hexbits.",null,null],[3,"Dibit","p25::bits","Two bits.",null,null],[3,"DibitParams","","Parameters for `Dibits` iterator.",null,null],[3,"Tribit","","Three bits.",null,null],[3,"TribitParams","","Parameters for `Tribits` iterator.",null,null],[3,"Hexbit","","Six bits.",null,null],[3,"HexbitParams","","Parameters for `Hexbits` iterator.",null,null],[3,"DibitByteParams","","Parameters for `DibitBytes` iterator.",null,null],[3,"TribitByteParams","","Parameters for `TribitBytes` iterator.",null,null],[3,"HexbitByteParams","","Parameters for `HexbitBytes` iterator.",null,null],[3,"SubByteIter","","An iterator for sub-byte (bit-level) values.",null,null],[6,"Dibits","","Iterate over the 2-bit symbols of a byte source, MSB to LSB.",null,null],[6,"Tribits","","Iterates over the 3-bit symbols of a byte source, MSB to LSB. The source must be a multiple of 3 bytes.",null,null],[6,"Hexbits","","Iterates over the 6-bit symbols of a byte source, MSB to LSB. The source must be a multiple of 3 bytes.",null,null],[6,"DibitBytes","","Groups dibits into full bytes. The source must be a multiple of 4 dibits.",null,null],[6,"TribitBytes","","Groups tribits into full bytes. The source must be a multiple of 8 tribits.",null,null],[6,"HexbitBytes","","Groups hexbits into full bytes. The source must be a multiple of 6 hexbits.",null,null],[8,"IterParams","","",null,null],[16,"Input","","Type to consume when buffering.",8,null],[16,"Output","","Type to yield at each iteration.",8,null],[10,"bits","","Number of bits to consume at each iteration.",8,{"inputs":[],"output":{"name":"usize"}}],[10,"buffer","","Number of input symbols to consume when buffering.",8,{"inputs":[],"output":{"name":"usize"}}],[10,"shift","","Amount to shift buffer after loading an input symbol.",8,{"inputs":[],"output":{"name":"usize"}}],[11,"post_shift","","Amount to shift buffer after all buffering, so the bits are lined up at the MSB.",8,{"inputs":[],"output":{"name":"usize"}}],[11,"iterations","","Number of iterations before buffering.",8,{"inputs":[],"output":{"name":"usize"}}],[10,"to_byte","","Convert input symbol to a byte.",8,null],[10,"to_output","","Convert bits to output type.",8,null],[11,"validate","","Verify the parameters are supported.",8,{"inputs":[],"output":null}],[11,"clone","","",9,{"inputs":[{"name":"self"}],"output":{"name":"dibit"}}],[11,"default","","",9,{"inputs":[],"output":{"name":"dibit"}}],[11,"fmt","","",9,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",9,{"inputs":[{"name":"self"},{"name":"dibit"}],"output":{"name":"bool"}}],[11,"ne","","",9,{"inputs":[{"name":"self"},{"name":"dibit"}],"output":{"name":"bool"}}],[11,"new","","Construct a new `Dibit` with the two given bits in the LSB position.",9,{"inputs":[{"name":"u8"}],"output":{"name":"dibit"}}],[11,"bits","","Get the wrapped dibit, which is guaranteed to have only 2 LSBs.",9,{"inputs":[{"name":"self"}],"output":{"name":"u8"}}],[11,"hi","","Get the MSB.",9,{"inputs":[{"name":"self"}],"output":{"name":"u8"}}],[11,"lo","","Get the LSB.",9,{"inputs":[{"name":"self"}],"output":{"name":"u8"}}],[11,"bits","","",10,{"inputs":[],"output":{"name":"usize"}}],[11,"buffer","","",10,{"inputs":[],"output":{"name":"usize"}}],[11,"shift","","",10,{"inputs":[],"output":{"name":"usize"}}],[11,"to_byte","","",10,null],[11,"to_output","","",10,{"inputs":[{"name":"u8"}],"output":{"name":"dibit"}}],[11,"clone","","",11,{"inputs":[{"name":"self"}],"output":{"name":"tribit"}}],[11,"default","","",11,{"inputs":[],"output":{"name":"tribit"}}],[11,"fmt","","",11,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",11,{"inputs":[{"name":"self"},{"name":"tribit"}],"output":{"name":"bool"}}],[11,"ne","","",11,{"inputs":[{"name":"self"},{"name":"tribit"}],"output":{"name":"bool"}}],[11,"new","","Construct a new `Tribit` with the three given bits in the LSB position.",11,{"inputs":[{"name":"u8"}],"output":{"name":"tribit"}}],[11,"bits","","Get the wrapped tribit, which is guaranteed to have only 3 LSBs.",11,{"inputs":[{"name":"self"}],"output":{"name":"u8"}}],[11,"bits","","",12,{"inputs":[],"output":{"name":"usize"}}],[11,"buffer","","",12,{"inputs":[],"output":{"name":"usize"}}],[11,"shift","","",12,{"inputs":[],"output":{"name":"usize"}}],[11,"to_byte","","",12,null],[11,"to_output","","",12,{"inputs":[{"name":"u8"}],"output":{"name":"tribit"}}],[11,"clone","","",13,{"inputs":[{"name":"self"}],"output":{"name":"hexbit"}}],[11,"default","","",13,{"inputs":[],"output":{"name":"hexbit"}}],[11,"fmt","","",13,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",13,{"inputs":[{"name":"self"},{"name":"hexbit"}],"output":{"name":"bool"}}],[11,"ne","","",13,{"inputs":[{"name":"self"},{"name":"hexbit"}],"output":{"name":"bool"}}],[11,"new","","Construct a new `Hexbit` with the 6 given bits in the LSB position.",13,{"inputs":[{"name":"u8"}],"output":{"name":"hexbit"}}],[11,"bits","","Get the wrapped hexbit, which is guaranteed to have only 6 LSBs.",13,{"inputs":[{"name":"self"}],"output":{"name":"u8"}}],[11,"bits","","",14,{"inputs":[],"output":{"name":"usize"}}],[11,"buffer","","",14,{"inputs":[],"output":{"name":"usize"}}],[11,"shift","","",14,{"inputs":[],"output":{"name":"usize"}}],[11,"to_byte","","",14,null],[11,"to_output","","",14,{"inputs":[{"name":"u8"}],"output":{"name":"hexbit"}}],[11,"bits","","",15,{"inputs":[],"output":{"name":"usize"}}],[11,"buffer","","",15,{"inputs":[],"output":{"name":"usize"}}],[11,"shift","","",15,{"inputs":[],"output":{"name":"usize"}}],[11,"to_byte","","",15,null],[11,"to_output","","",15,null],[11,"bits","","",16,{"inputs":[],"output":{"name":"usize"}}],[11,"buffer","","",16,{"inputs":[],"output":{"name":"usize"}}],[11,"shift","","",16,{"inputs":[],"output":{"name":"usize"}}],[11,"to_byte","","",16,null],[11,"to_output","","",16,null],[11,"bits","","",17,{"inputs":[],"output":{"name":"usize"}}],[11,"buffer","","",17,{"inputs":[],"output":{"name":"usize"}}],[11,"shift","","",17,{"inputs":[],"output":{"name":"usize"}}],[11,"to_byte","","",17,null],[11,"to_output","","",17,null],[11,"new","","Construct a new `SubByteIter` over the given symbol source.",18,{"inputs":[{"name":"t"}],"output":{"name":"subbyteiter"}}],[11,"next","","",18,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[0,"coding","p25","Encoding and decoding for the several error correction coding schemes used in P25.",null,null],[0,"galois","p25::coding","Galois field arithmetic for codewords and polynomials.",null,null],[3,"P25Field","p25::coding::galois","GF(26) field characterized by α6+α+1, as described in the P25 specification.",null,null],[3,"Codeword","","Codeword in a Galois field.",null,null],[3,"Polynomial","","Polynomial with P25's GF(26) codewords as coefficients.",null,null],[6,"P25Codeword","","Codeword in the P25 Galois field.",null,null],[8,"GaloisField","","A GF(2r) Galois field.",null,null],[10,"size","","Number of unique codewords in the field: 2r - 1.",19,{"inputs":[],"output":{"name":"usize"}}],[10,"valid_codeword","","Check if the given bit pattern is a valid codeword in the field.",19,{"inputs":[{"name":"u8"}],"output":{"name":"bool"}}],[10,"codeword","","Map the given power i to codeword αi.",19,{"inputs":[{"name":"usize"}],"output":{"name":"u8"}}],[10,"power","","Map the given codeword ai to its power i.",19,{"inputs":[{"name":"usize"}],"output":{"name":"usize"}}],[11,"codeword_modded","","Map the given power i to codeword αm ≡ αi (modulo the size of the field.)",19,{"inputs":[{"name":"usize"}],"output":{"name":"u8"}}],[8,"PolynomialCoefs","","Coefficient storage for a bounded-degree Galois polynomial of a particular code.",null,null],[10,"distance","","The minimum Hamming distance, d, in (n,k,d).",20,{"inputs":[],"output":{"name":"usize"}}],[11,"errors","","Maximum number of correctable errors: t.",20,{"inputs":[],"output":{"name":"usize"}}],[11,"syndromes","","Number of syndromes: 2t.",20,{"inputs":[],"output":{"name":"usize"}}],[11,"validate","","Verify the implementer is well-formed.",20,{"inputs":[{"name":"self"}],"output":null}],[11,"clone","","",21,{"inputs":[{"name":"self"}],"output":{"name":"p25field"}}],[11,"fmt","","",21,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"size","","",21,{"inputs":[],"output":{"name":"usize"}}],[11,"valid_codeword","","",21,{"inputs":[{"name":"u8"}],"output":{"name":"bool"}}],[11,"codeword","","",21,{"inputs":[{"name":"usize"}],"output":{"name":"u8"}}],[11,"power","","",21,{"inputs":[{"name":"usize"}],"output":{"name":"usize"}}],[11,"clone","","",22,{"inputs":[{"name":"self"}],"output":{"name":"codeword"}}],[11,"new","","Construct a new `Codeword` αi from the given bit pattern. Panic if the pattern is invalid in the field.",22,{"inputs":[{"name":"u8"}],"output":{"name":"codeword"}}],[11,"for_power","","Construct a new `Codeword` αm ≡ αi (modulo the field) for the given power i.",22,{"inputs":[{"name":"usize"}],"output":{"name":"codeword"}}],[11,"bits","","Retrieve the bit pattern of the codeword.",22,{"inputs":[{"name":"self"}],"output":{"name":"u8"}}],[11,"zero","","Check if the codeword is zero.",22,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"power","","Retrieve the power i of the current codeword αi. Return `Some(i)` if the power is defined and `None` if the codeword is zero.",22,{"inputs":[{"name":"self"}],"output":{"generics":["usize"],"name":"option"}}],[11,"invert","","Find 1/αi for the current codeword αi. Panic if the codeword is zero.",22,{"inputs":[{"name":"self"}],"output":{"name":"codeword"}}],[11,"pow","","Compute (αi)p for the current codeword αi and given power p.",22,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"codeword"}}],[11,"default","","Construct the additive identity codeword α0 = 1.",22,{"inputs":[],"output":{"name":"self"}}],[11,"add","","",22,null],[11,"sub","","",22,null],[11,"mul","","",22,null],[11,"div","","",22,null],[11,"eq","","",22,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"bool"}}],[11,"eq","","",22,{"inputs":[{"name":"self"},{"name":"u8"}],"output":{"name":"bool"}}],[11,"fmt","","",22,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"clone","","",23,{"inputs":[{"name":"self"}],"output":{"name":"polynomial"}}],[11,"new","","Construct a new `Polynomial` from the given coefficients c0, ..., ck.",23,{"inputs":[{"name":"t"}],"output":{"name":"self"}}],[11,"unit_power","","Construct a new `Polynomial` with the single term p(x) = xn.",23,{"inputs":[{"name":"usize"}],"output":{"name":"self"}}],[11,"constant","","Retrieve the degree-0 coefficient, c0.",23,{"inputs":[{"name":"self"}],"output":{"name":"p25codeword"}}],[11,"degree","","Compute deg(p(x)), returned as `Some(deg)` if the polynomial is nonzero, or `None` if p(x) = 0.",23,{"inputs":[{"name":"self"}],"output":{"generics":["usize"],"name":"option"}}],[11,"shift","","Divide the polynomial by x -- shift all coefficients to a lower degree. Panic if c0 ≠ 0.",23,{"inputs":[{"name":"self"}],"output":{"name":"polynomial"}}],[11,"coef","","Retrieve the coefficient ci associated with the xi term.",23,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"p25codeword"}}],[11,"eval","","Evaluate p(x), substituting in the given x.",23,{"inputs":[{"name":"self"},{"name":"p25codeword"}],"output":{"name":"p25codeword"}}],[11,"truncate","","Truncate the polynomial so that deg(p(x)) ≤ d, where d is the given degree.",23,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"polynomial"}}],[11,"deriv","","Compute the formal derivative p'(x).",23,{"inputs":[{"name":"self"}],"output":{"name":"polynomial"}}],[11,"default","","Construct an empty polynomial, p(x) = 0.",23,{"inputs":[],"output":{"name":"self"}}],[11,"deref","","",23,null],[11,"deref_mut","","",23,null],[11,"add","","",23,null],[11,"mul","","",23,null],[11,"mul","","",23,null],[11,"fmt","","",23,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[0,"bch","p25::coding","Encoding and decoding of the (63, 16, 23) BCH code described by P25.",null,null],[5,"encode","p25::coding::bch","Encode the given 16 data bits into a 64-bit codeword.",null,{"inputs":[{"name":"u16"}],"output":{"name":"u64"}}],[5,"decode","","Try to decode the given 64-bit word to the nearest codeword, correcting up to 11 bit errors.",null,{"inputs":[{"name":"u64"}],"output":{"name":"option"}}],[0,"bmcf","p25::coding","Decodes Reed Solomon and BCH codes using the Berlekamp-Massey, Chien Search, and Forney algorithms.",null,null],[3,"ErrorLocator","p25::coding::bmcf","Finds the error location polynomial Λ(x) from the syndrome polynomial s(x).",null,null],[3,"PolynomialRoots","","Finds the roots of the given error locator polynomial Λ(x).",null,null],[3,"ErrorDescriptions","","Computes error locations and patterns from the roots of the error locator polynomial Λ(x).",null,null],[3,"Errors","","Decodes and iterates over codeword errors.",null,null],[11,"new","","Construct a new `ErrorLocator` from the given syndrome polynomial s(x).",24,{"inputs":[{"name":"polynomial"}],"output":{"name":"errorlocator"}}],[11,"build","","Construct the error locator polynomial Λ(x).",24,{"inputs":[{"name":"self"}],"output":{"name":"polynomial"}}],[11,"new","","Construct a new `PolynomialRoots` from the given error locator polynomial Λ(x).",25,{"inputs":[{"name":"polynomial"}],"output":{"name":"self"}}],[11,"next","","",25,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"new","","Create a new `ErrorDescriptions` from the given syndrome polynomial s(x) and error locator polynomial Λ(x).",26,{"inputs":[{"name":"polynomial"},{"name":"polynomial"}],"output":{"name":"self"}}],[11,"for_root","","Compute the error location and pattern for the given root ai-1 of Λ(x).",26,null],[11,"new","","Create a new `Errors` decoder from the given syndrome polynomial s(x).",27,{"inputs":[{"name":"polynomial"}],"output":{"name":"option"}}],[11,"next","","",27,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[0,"cyclic","p25::coding","Encoding and decoding of the (16, 8, 5) shortened cyclic code described by P25.",null,null],[5,"encode","p25::coding::cyclic","Encode the given 8 data bits into a 16-bit codeword.",null,{"inputs":[{"name":"u8"}],"output":{"name":"u16"}}],[5,"decode","","Try to decode the given 16-bit word to the nearest codeword, correcting up to 2 errors.",null,{"inputs":[{"name":"u16"}],"output":{"name":"option"}}],[0,"golay","p25::coding","Encoding and decoding of the (23, 12, 7) standard, (24, 12, 8) extended, and (18, 6, 8) shortened Golay codes described by P25.",null,null],[0,"standard","p25::coding::golay","Encoding and decoding of the (23, 12, 7) code.",null,null],[5,"encode","p25::coding::golay::standard","Encode the given 12 data bits into a 23-bit codeword.",null,{"inputs":[{"name":"u16"}],"output":{"name":"u32"}}],[5,"decode","","Try to decode the given 23-bit word to the nearest codeword, correcting up to 3 errors.",null,{"inputs":[{"name":"u32"}],"output":{"name":"option"}}],[0,"extended","p25::coding::golay","Encoding and decoding of the (24, 12, 8) code.",null,null],[5,"encode","p25::coding::golay::extended","Encode the given 12 data bits into a 24-bit codeword.",null,{"inputs":[{"name":"u16"}],"output":{"name":"u32"}}],[5,"decode","","Try to decode the given  24-bit word to the nearest codeword, correcting up to 3 errors.",null,{"inputs":[{"name":"u32"}],"output":{"name":"option"}}],[0,"shortened","p25::coding::golay","Encoding and decoding of the (18, 6, 8) code.",null,null],[5,"encode","p25::coding::golay::shortened","Encode the given 6 data bits to an 18-bit codeword.",null,{"inputs":[{"name":"u8"}],"output":{"name":"u32"}}],[5,"decode","","Try to decode the given 18-bit word to the nearest codeword, correcting up to 3 errors.",null,{"inputs":[{"name":"u32"}],"output":{"name":"option"}}],[0,"hamming","p25::coding","Encoding and decoding of the (15, 11, 3) standard and (10, 6, 3) shortened Hamming codes described by P25.",null,null],[0,"standard","p25::coding::hamming","Encoding and decoding of the (15, 11, 3) code.",null,null],[5,"encode","p25::coding::hamming::standard","Encode the given 11 bits of data into a 15-bit codeword.",null,{"inputs":[{"name":"u16"}],"output":{"name":"u16"}}],[5,"decode","","Try to decode the given 15-bit word to the nearest codeword, correcting up to 1 error.",null,{"inputs":[{"name":"u16"}],"output":{"name":"option"}}],[0,"shortened","p25::coding::hamming","Encoding and decoding of the (10, 6, 3) code.",null,null],[5,"encode","p25::coding::hamming::shortened","Encode the given 6 data bits into a 10-bit codeword.",null,{"inputs":[{"name":"u8"}],"output":{"name":"u16"}}],[5,"decode","","Try to decode the given 10-bit word to the nearest codeword, correcting up to 1 error.",null,{"inputs":[{"name":"u16"}],"output":{"name":"option"}}],[0,"reed_solomon","p25::coding","Encoding and decoding of the (24, 12, 13) short, (24, 16, 9) medium, and (36, 20, 17) long Reed-Solomon codes described by P25.",null,null],[0,"short","p25::coding::reed_solomon","Encoding and decoding of the (24, 12, 13) code.",null,null],[5,"encode","p25::coding::reed_solomon::short","Calculate the 12 parity hexbits for the first 12 data hexbits in the given buffer, placing the parity hexbits at the end of the buffer.",null,null],[5,"decode","","Try to decode the given 24-hexbit word to the nearest codeword, correcting up to 6 hexbit errors (up to 36 bit errors.)",null,null],[0,"medium","p25::coding::reed_solomon","Encoding and decoding of the (24, 16, 9) code.",null,null],[5,"encode","p25::coding::reed_solomon::medium","Calculate the 8 parity hexbits for the first 16 data hexbits in the given buffer, placing the parity hexbits at the end of the buffer.",null,null],[5,"decode","","Try to decode the given 24-hexbit word to the nearest codeword, correcting up to 4 hexbit errors (up to 24 bit errors.)",null,null],[0,"long","p25::coding::reed_solomon","Encoding and decoding of the (36, 20, 17) code.",null,null],[5,"encode","p25::coding::reed_solomon::long","Calculate the 16 parity hexbits for the first 20 data hexbits in the given buffer, placing the parity hexbits at the end of the buffer.",null,null],[5,"decode","","Try to decode the given 36-hexbit word to the nearest codeword, correcting up to 8 hexbit errors (up to 48 bit errors.)",null,null],[0,"trellis","p25::coding","Implements encoding and decoding of the \"trellis\" convolutional error correcting code specified by P25.",null,null],[3,"DibitStates","p25::coding::trellis","Half-rate state machine (dibit input).",null,null],[3,"TribitStates","","3/4-rate state machine (tribit input).",null,null],[3,"TrellisFSM","","Convolutional code finite state machine with the given transition table. Each fed-in symbol is used as the next state.",null,null],[3,"DibitHistory","","",null,null],[3,"TribitHistory","","",null,null],[3,"DibitWalks","","",null,null],[3,"TribitWalks","","",null,null],[3,"ViterbiDecoder","","Decodes a received convolutional code dibit stream to a nearby codeword using the truncated Viterbi algorithm.",null,null],[3,"Walk","","",null,null],[12,"distance","","",28,null],[6,"DibitFSM","","Half-rate convolutional (\"trellis\") code state machine.",null,null],[6,"TribitFSM","","3/4-rate convolutional (\"trellis\") code state machine.",null,null],[6,"DibitDecoder","","Half-rate convolution (\"trellis\") code decoder.",null,null],[6,"TribitDecoder","","3/4-rate convolution (\"trellis\") code decoder.",null,null],[8,"States","","",null,null],[16,"Symbol","","Symbol type to use for states and input.",29,null],[10,"size","","Number of rows/columns in the state machine.",29,{"inputs":[],"output":{"name":"usize"}}],[10,"pair_idx","","Get the \"constellation point\" on the transition from the current state to the next state.",29,{"inputs":[{"name":"usize"},{"name":"usize"}],"output":{"name":"usize"}}],[10,"state","","Convert the given symbol to a state.",29,null],[10,"symbol","","Convert the given state to a symbol.",29,null],[10,"finisher","","Get the \"flushing\" symbol fed in at the end of a stream.",29,null],[11,"pair","","Get the dibit pair on the transition from the current state to the next state.",29,null],[8,"WalkHistory","","",null,null],[10,"history","","The length of each walk associated with each state. This also determines the delay before the first decoded symbol is yielded.",30,{"inputs":[],"output":{"name":"usize"}}],[8,"Walks","","",null,null],[10,"states","","",31,{"inputs":[],"output":{"name":"usize"}}],[11,"size","","",32,{"inputs":[],"output":{"name":"usize"}}],[11,"pair_idx","","",32,{"inputs":[{"name":"usize"},{"name":"usize"}],"output":{"name":"usize"}}],[11,"state","","",32,{"inputs":[{"name":"dibit"}],"output":{"name":"usize"}}],[11,"finisher","","",32,null],[11,"symbol","","",32,null],[11,"size","","",33,{"inputs":[],"output":{"name":"usize"}}],[11,"pair_idx","","",33,{"inputs":[{"name":"usize"},{"name":"usize"}],"output":{"name":"usize"}}],[11,"state","","",33,{"inputs":[{"name":"tribit"}],"output":{"name":"usize"}}],[11,"finisher","","",33,null],[11,"symbol","","",33,null],[11,"new","","Construct a new `TrellisFSM` at the initial state.",34,{"inputs":[],"output":{"name":"trellisfsm"}}],[11,"feed","","Apply the given symbol to the state machine and return the dibit pair on the transition.",34,null],[11,"finish","","Flush the state machine with the finishing symbol and return the final transition.",34,null],[11,"clone","","",35,{"inputs":[{"name":"self"}],"output":{"name":"dibithistory"}}],[11,"default","","",35,{"inputs":[],"output":{"name":"dibithistory"}}],[11,"deref","","",35,null],[11,"deref_mut","","",35,null],[11,"history","","",35,{"inputs":[],"output":{"name":"usize"}}],[11,"clone","","",36,{"inputs":[{"name":"self"}],"output":{"name":"tribithistory"}}],[11,"default","","",36,{"inputs":[],"output":{"name":"tribithistory"}}],[11,"deref","","",36,null],[11,"deref_mut","","",36,null],[11,"history","","",36,{"inputs":[],"output":{"name":"usize"}}],[11,"clone","","",37,{"inputs":[{"name":"self"}],"output":{"name":"dibitwalks"}}],[11,"deref","","",37,null],[11,"deref_mut","","",37,null],[11,"states","","",37,{"inputs":[],"output":{"name":"usize"}}],[11,"default","","",37,{"inputs":[],"output":{"name":"self"}}],[11,"clone","","",38,{"inputs":[{"name":"self"}],"output":{"name":"tribitwalks"}}],[11,"deref","","",38,null],[11,"deref_mut","","",38,null],[11,"states","","",38,{"inputs":[],"output":{"name":"usize"}}],[11,"default","","",38,{"inputs":[],"output":{"name":"self"}}],[11,"new","","Construct a new `ViterbiDecoder` over the given dibit source.",39,{"inputs":[{"name":"t"}],"output":{"name":"viterbidecoder"}}],[11,"next","","",39,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"clone","","",28,{"inputs":[{"name":"self"}],"output":{"name":"walk"}}],[11,"fmt","","",28,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","",28,{"inputs":[{"name":"usize"}],"output":{"name":"walk"}}],[11,"append","","",28,{"inputs":[{"name":"self"},{"name":"self"}],"output":null}],[11,"combine","","",28,{"inputs":[{"name":"self"},{"name":"self"},{"name":"usize"}],"output":{"name":"self"}}],[11,"replace","","",28,{"inputs":[{"name":"self"},{"name":"self"},{"name":"usize"}],"output":{"name":"self"}}],[11,"deref","","",28,null],[11,"deref_mut","","",28,null],[11,"default","","",28,{"inputs":[],"output":{"name":"self"}}],[0,"consts","p25","Constants used throughout the protocol.",null,null],[17,"SYMBOL_RATE","p25::consts","Symbols (dibits) per second.",null,null],[17,"SAMPLE_RATE","","Baseband samples per second",null,null],[17,"SYMBOL_PERIOD","","Baseband samples per symbol.",null,null],[17,"SYNC_SYMBOLS","","Number of symbols in the frame sync sequence.",null,null],[17,"NID_DIBITS","","Number of dibits in a coded NID word.",null,null],[17,"CODING_DIBITS","","Number of dibits that are input to the 1/2 or 3/4-rate trellis coder.",null,null],[17,"TSBK_DIBITS","","Number of dibits in an uncoded TSBK packet.",null,null],[17,"TSBK_BYTES","","Number of bytes in an uncoded TSBK packet.",null,null],[17,"FRAME_DIBITS","","Number of dibits in a coded voice frame.",null,null],[17,"HEADER_HEXBITS","","Number of hexbits in a coded voice header packet.",null,null],[17,"HEADER_BYTES","","Number of bytes in an uncoded voice header packet.",null,null],[17,"EXTRA_HEXBITS","","Number of hexbits in a coded voice extra packet.",null,null],[17,"LINK_CONTROL_BYTES","","Number of bytes in a link control word.",null,null],[17,"CRYPTO_CONTROL_BYTES","","Number of bytes in a crypto control word.",null,null],[17,"EXTRA_PIECE_DIBITS","","Number of dibits in an LC/CC piece. An LC/CC word is spread over 6 equal-sized pieces in each frame group, for a total of 120 dibits.",null,null],[17,"EXTRA_WORD_DIBITS","","Number of dibits in each coded word that makes up a voice extra component.",null,null],[17,"DATA_FRAG_DIBITS","","Number of dibits in the voice data fragment.",null,null],[17,"HEADER_WORD_DIBITS","","Number of dibits in each coded word that makes up the voice header packet.",null,null],[17,"LC_TERM_WORD_DIBITS","","Number of dibits in each coded word that makes up the voice LC terminator packet.",null,null],[0,"data","p25","Implements Project 25's data packet specification.",null,null],[0,"coder","p25::data","Provides a convenience interface for coding symbols into a buffer.",null,null],[3,"DataCoder","p25::data::coder","",null,null],[6,"DibitCoder","","Half-rate (dibit) convolutional coder.",null,null],[6,"TribitCoder","","3/4-rate (tribit) convolutional coder.",null,null],[11,"finish","","Flush the state machine and return the coded buffer of dibits.",40,null],[11,"new","","Construct a new `DibitCoder` for coding a dibit stream.",41,{"inputs":[],"output":{"name":"dibitcoder"}}],[11,"feed_bytes","","Code the given bytes as dibits.",41,{"inputs":[{"name":"self"},{"name":"t"}],"output":{"name":"self"}}],[11,"new","","Construct a new `TribitCoder` for coding a tribit stream.",42,{"inputs":[],"output":{"name":"tribitcoder"}}],[11,"feed_bytes","","Code the given bytes as tribits.",42,{"inputs":[{"name":"self"},{"name":"t"}],"output":{"name":"self"}}],[0,"crc","p25::data","Implements the 9, 16, and 32-bit CRCs defined by P25 for data checksums.",null,null],[3,"CRC9Params","p25::data::crc","Params for 9-bit CRC.",null,null],[3,"CRC16Params","","Params for 16-bit CRC.",null,null],[3,"CRC32Params","","Params for 32-bit CRC.",null,null],[3,"CRC","","CRC calculator using long division.",null,null],[6,"CRC9","","9-bit CRC calculator.",null,null],[6,"CRC16","","16-bit CRC calculator.",null,null],[6,"CRC32","","32-bit CRC calculator.",null,null],[8,"CRCParams","","",null,null],[10,"gen","","Generator polynomial, with the MSB being the coefficient of highest degree.",43,{"inputs":[],"output":{"name":"u64"}}],[10,"inv","","Inversion polynomial, with the MSB being the coefficient of highest degree.",43,{"inputs":[],"output":{"name":"u64"}}],[10,"shift","","Amount to left-shift the message (multiply by x^i) before division.",43,{"inputs":[],"output":{"name":"usize"}}],[11,"validate","","Verify the parameters are well-formed.",43,{"inputs":[],"output":null}],[11,"gen","","",44,{"inputs":[],"output":{"name":"u64"}}],[11,"inv","","",44,{"inputs":[],"output":{"name":"u64"}}],[11,"shift","","",44,{"inputs":[],"output":{"name":"usize"}}],[11,"gen","","",45,{"inputs":[],"output":{"name":"u64"}}],[11,"inv","","",45,{"inputs":[],"output":{"name":"u64"}}],[11,"shift","","",45,{"inputs":[],"output":{"name":"usize"}}],[11,"gen","","",46,{"inputs":[],"output":{"name":"u64"}}],[11,"inv","","",46,{"inputs":[],"output":{"name":"u64"}}],[11,"shift","","",46,{"inputs":[],"output":{"name":"usize"}}],[11,"new","","Construct a new `CRC` with empty output.",47,{"inputs":[],"output":{"name":"crc"}}],[11,"feed_bits","","Feed in `num` LSBs of the given byte.",47,{"inputs":[{"name":"self"},{"name":"u8"},{"name":"usize"}],"output":{"name":"self"}}],[11,"feed_bytes","","Feed in the given byte stream.",47,{"inputs":[{"name":"self"},{"name":"t"}],"output":{"name":"self"}}],[11,"finish","","Finish the CRC calculation and return the resulting CRC.",47,{"inputs":[{"name":"self"}],"output":{"name":"u64"}}],[0,"fields","p25::data","Data packet fields.",null,null],[4,"DataPacketOpcode","p25::data::fields","Data packet type present in every header.",null,null],[13,"ConfirmedPacket","","Confirmed packet that requires an acknowledgement response from the recipient.",48,null],[13,"UnconfirmedPacket","","Unconfirmed packet that doesn't require an acknowledgement response from the recipient.",48,null],[13,"ResponsePacket","","Response to the sender of a confirmed data packet.",48,null],[13,"TrunkingPacket","","Multiblock trunking data packet.",48,null],[4,"ServiceAccessPoint","","Destination service for data packet.",null,null],[13,"UnencryptedUserData","","",49,null],[13,"EncryptedUserData","","",49,null],[13,"CircuitData","","",49,null],[13,"CircuitDataControl","","",49,null],[13,"PacketData","","",49,null],[13,"ARP","","",49,null],[13,"SNDCPControl","","",49,null],[13,"ExtendedAddressing","","",49,null],[13,"RegistrationAuth","","",49,null],[13,"ChannelReassignment","","",49,null],[13,"SystemConfiguration","","",49,null],[13,"Loopback","","",49,null],[13,"Statistics","","",49,null],[13,"OutOfService","","",49,null],[13,"Paging","","",49,null],[13,"Configuration","","",49,null],[13,"UnencryptedKeyManagement","","",49,null],[13,"EncryptedKeyManagement","","",49,null],[13,"TrunkingControl","","",49,null],[13,"EncryptedTrunkingControl","","",49,null],[11,"clone","","",48,{"inputs":[{"name":"self"}],"output":{"name":"datapacketopcode"}}],[11,"eq","","",48,{"inputs":[{"name":"self"},{"name":"datapacketopcode"}],"output":{"name":"bool"}}],[11,"fmt","","",48,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"to_bits","","Convert packet type to its 5-bit representation.",48,{"inputs":[{"name":"self"}],"output":{"name":"u8"}}],[11,"from_bits","","Parse a packet type from the given 5 bits.",48,{"inputs":[{"name":"u8"}],"output":{"generics":["datapacketopcode"],"name":"option"}}],[11,"clone","","",49,{"inputs":[{"name":"self"}],"output":{"name":"serviceaccesspoint"}}],[11,"eq","","",49,{"inputs":[{"name":"self"},{"name":"serviceaccesspoint"}],"output":{"name":"bool"}}],[11,"fmt","","",49,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"from_bits","","Convert the given 6 bits to a SAP identifier.",49,{"inputs":[{"name":"u8"}],"output":{"generics":["serviceaccesspoint"],"name":"option"}}],[11,"to_bits","","Convert SAP identifier to its 6-bit representation.",49,{"inputs":[{"name":"self"}],"output":{"name":"u8"}}],[0,"fragment","p25::data","Provides `Fragments` iterator for splitting a data slice into fragment slices, whose size depends on the data packet used.",null,null],[3,"Fragments","p25::data::fragment","Iterator over data fragments, yielding fragment-sized data slices to be turned into payload blocks.",null,null],[6,"ConfirmedFragments","","Fragments for confirmed data packets.",null,null],[6,"UnconfirmedFragments","","Fragments for unconfirmed data packets.",null,null],[11,"new","","Construct a new `Fragments` over the given data.",50,null],[11,"next","","",50,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[0,"header","p25::data","Header generation for data packets.",null,null],[3,"HeaderPreamble","p25::data::header","Preamble header field.",null,null],[12,"confirmed","","Whether the packet requires confirmation.",51,null],[12,"outbound","","Whether the packet is an outbound message.",51,null],[12,"format","","Packet type.",51,null],[3,"ConfirmedPreamble","","Preamble for confirmed data packet.",null,null],[3,"UnconfirmedPreamble","","Preamble for unconfirmed data packet.",null,null],[3,"ServiceAccessPoint","","Service access point (SAP) field.",null,null],[12,"0","","",52,null],[3,"Manufacturer","","Manufacturer's ID field.",null,null],[12,"0","","",53,null],[3,"LogicalLink","","Logical link ID field for addressing source or destination subscriber.",null,null],[12,"0","","",54,null],[3,"BlockCount","","FMF and blocks-to-follow fields.",null,null],[12,"full_pkt","","Whether the packet is \"complete\", not being partially retransmitted.",55,null],[12,"count","","Number of data blocks in the packet.",55,null],[3,"PadCount","","Number of pad bytes at the end of the data.",null,null],[12,"0","","",56,null],[3,"Sequencing","","Syn, N(S), and FSNF fields.",null,null],[12,"resync","","Whether the receiver should resynchronize its sequence numbers using `pkt_seq` and `frag_seq`.",57,null],[12,"pkt_seq","","Packet sequence number, used for ordering and duplicate removal.",57,null],[12,"frag_seq","","Fragment sequence number, used when data is split across multiple fragments.",57,null],[3,"DataOffset","","Byte offset into data payload where data header stops and data information begins.",null,null],[12,"0","","",58,null],[3,"ConfirmedFields","","Header fields for confirmed packet.",null,null],[12,"preamble","","",59,null],[12,"sap","","",59,null],[12,"mfg","","",59,null],[12,"addr","","",59,null],[12,"blocks","","",59,null],[12,"pads","","",59,null],[12,"seq","","",59,null],[12,"data_offset","","",59,null],[3,"UnconfirmedFields","","Header fields for unconfirmed packet.",null,null],[12,"preamble","","",60,null],[12,"sap","","",60,null],[12,"mfg","","",60,null],[12,"addr","","",60,null],[12,"blocks","","",60,null],[12,"pads","","",60,null],[12,"data_offset","","",60,null],[3,"Header","","Builds a checksummed header based on the given fields.",null,null],[6,"ConfirmedHeader","","Packet header block for confirmed data packet.",null,null],[6,"UnconfirmedHeader","","Packet header block for unconfirmed data packet.",null,null],[8,"BufWrite","","Write some bytes into a buffer.",null,null],[10,"write","","",61,{"inputs":[{"name":"self"},{"name":"t"}],"output":null}],[8,"ByteField","","Field is only a single byte.",null,null],[10,"byte","","",62,{"inputs":[{"name":"self"}],"output":{"name":"u8"}}],[11,"byte","","",51,{"inputs":[{"name":"self"}],"output":{"name":"u8"}}],[11,"outbound","","",63,{"inputs":[],"output":{"name":"self"}}],[11,"inbound","","",63,{"inputs":[],"output":{"name":"self"}}],[11,"byte","","",63,{"inputs":[{"name":"self"}],"output":{"name":"u8"}}],[11,"outbound","","",64,{"inputs":[],"output":{"name":"self"}}],[11,"inbound","","",64,{"inputs":[],"output":{"name":"self"}}],[11,"byte","","",64,{"inputs":[{"name":"self"}],"output":{"name":"u8"}}],[11,"byte","","",52,{"inputs":[{"name":"self"}],"output":{"name":"u8"}}],[11,"byte","","",53,{"inputs":[{"name":"self"}],"output":{"name":"u8"}}],[11,"write","","",54,{"inputs":[{"name":"self"},{"name":"t"}],"output":null}],[11,"byte","","",55,{"inputs":[{"name":"self"}],"output":{"name":"u8"}}],[11,"byte","","",56,{"inputs":[{"name":"self"}],"output":{"name":"u8"}}],[11,"byte","","",57,{"inputs":[{"name":"self"}],"output":{"name":"u8"}}],[11,"byte","","",58,{"inputs":[{"name":"self"}],"output":{"name":"u8"}}],[11,"write","","",59,{"inputs":[{"name":"self"},{"name":"t"}],"output":null}],[11,"write","","",60,{"inputs":[{"name":"self"},{"name":"t"}],"output":null}],[11,"new","","Construct a new `Header` with the given fields.",65,{"inputs":[{"name":"f"}],"output":{"name":"header"}}],[11,"build","","Get the fields and checksum that make up the header, in that order.",65,null],[0,"interleave","p25::data","Interleaving and deinterleaving for data packet payloads.",null,null],[3,"Interleaver","p25::data::interleave","Takes ownership of a dibit buffer, yielding deinterleaved dibits.",null,null],[3,"Deinterleaver","","",null,null],[11,"new","","Construct a new `Interleaver` over the given buffer.",66,null],[11,"next","","",66,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"new","","",67,null],[11,"next","","",67,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[0,"packet","p25::data","Generate data packets.",null,null],[5,"confirmed","p25::data::packet","Construct a confirmed data packet with the given header, payload blocks, and serial number generator. The returned value is the coded, interleaved set of dibit symbols that make up the packet.",null,{"inputs":[{"name":"confirmedheader"},{"name":"confirmedpayload"},{"name":"s"}],"output":{"generics":["dibit"],"name":"vec"}}],[5,"unconfirmed","","Construct an unconfirmed data packet with the given header and payload blocks. The returned value is the coded, interleaved set of dibit symbols that make up the packet.",null,{"inputs":[{"name":"unconfirmedheader"},{"name":"unconfirmedpayload"}],"output":{"generics":["dibit"],"name":"vec"}}],[0,"params","p25::data","Defines various parameters used for data packets.",null,null],[3,"ConfirmedParams","p25::data::params","Params for confirmed data packets.",null,null],[3,"UnconfirmedParams","","Params for unconfirmed data packets.",null,null],[8,"PacketParams","","",null,null],[10,"block_bytes","","Number of data bytes in a normal block.",68,{"inputs":[],"output":{"name":"usize"}}],[10,"tail_bytes","","Number of data bytes in the tail block.",68,{"inputs":[],"output":{"name":"usize"}}],[11,"max_blocks","","Maximum number of blocks in the packet, including the tail block.",68,{"inputs":[],"output":{"name":"usize"}}],[11,"packet_bytes","","Maximum number of data bytes in the packet.",68,{"inputs":[],"output":{"name":"usize"}}],[11,"blocks","","Calculate the total number of data blocks (normal and tail) needed to hold the given amount of bytes.",68,{"inputs":[{"name":"usize"}],"output":{"name":"usize"}}],[11,"pads","","Calculate the number of pads needed for the tail block (and possibly second-to-last block) for the given amount of bytes.",68,{"inputs":[{"name":"usize"}],"output":{"name":"usize"}}],[11,"full_blocks","","Calculate the number of normal data blocks (tail block not included) needed to hold the given amount of bytes.",68,{"inputs":[{"name":"usize"}],"output":{"name":"usize"}}],[11,"block_bytes","","",69,{"inputs":[],"output":{"name":"usize"}}],[11,"tail_bytes","","",69,{"inputs":[],"output":{"name":"usize"}}],[11,"block_bytes","","",70,{"inputs":[],"output":{"name":"usize"}}],[11,"tail_bytes","","",70,{"inputs":[],"output":{"name":"usize"}}],[0,"payload","p25::data","Generate data blocks from a slice of bytes.",null,null],[3,"Payload","p25::data::payload","Wraps a buffer of bytes, splitting them over payload blocks.",null,null],[3,"PayloadIter","","Iterator over the normal (non-tail) blocks in a payload.",null,null],[3,"PayloadBlock","","Normal payload block.",null,null],[3,"TailBlock","","Tail payload block, which has the packet checksum.",null,null],[3,"ConfirmedBlockHeader","","Additional fields used in confirmed data packet blocks.",null,null],[6,"ConfirmedPayload","","Payload blocks for a confirmed data packet.",null,null],[6,"UnconfirmedPayload","","Payload blocks for an unconfirmed data packet.",null,null],[11,"new","","Construct a new `Payload` over the given data bytes.",71,null],[11,"blocks","","Total number of blocks in the payload.",71,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"pads","","Number of pad bytes in the payload.",71,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"iter","","Construct an iterator over the normal blocks for the payload.",71,{"inputs":[{"name":"self"}],"output":{"name":"payloaditer"}}],[11,"tail","","Get the tail block of the payload.",71,{"inputs":[{"name":"self"}],"output":{"name":"tailblock"}}],[11,"new","","Construct a new `PayloadIter` from the given data bytes.",72,null],[11,"next","","",72,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"new","","Construct a new `PayloadBlock` from the given data bytes.",73,null],[11,"build","","Get the data and pad bytes that make up the block, in that order.",73,null],[11,"new","","Construct a new `TailBlock` from the given data bytes and packet checksum.",74,null],[11,"build","","Get the data, pad, and checksum bytes that make up the block, in that order.",74,null],[11,"new","","Construct a new `ConfirmedBlockHeader` from the given 7-bit serial number, and use the given data and pads to calculate the checksum.",75,null],[11,"build","","Get the header field.",75,null],[0,"error","p25","Standard errors that may occur when working with P25.",null,null],[4,"P25Error","p25::error","P25 runtime errors.",null,null],[13,"RsShortUnrecoverable","","Too many errors were detected when attempting an RS-short decode.",76,null],[13,"RsMediumUnrecoverable","","Too many errors were detected when attempting an RS-medium decode.",76,null],[13,"RsLongUnrecoverable","","Too many errors were detected when attempting an RS-long decode.",76,null],[13,"BchUnrecoverable","","Too many errors were detected when attempting a BCH decode.",76,null],[13,"GolayStdUnrecoverable","","Too many errors were detected when attempting a standard Golay decode.",76,null],[13,"GolayShortUnrecoverable","","Too many errors were detected when attempting a shortened Golay decode.",76,null],[13,"GolayExtUnrecoverable","","Too many errors were detected when attempting an extended Golay decode.",76,null],[13,"HammingStdUnrecoverable","","Too many errors were detected when attempting a standard Hamming decode.",76,null],[13,"HammingShortUnrecoverable","","Too many errors were detected when attempting a shortened Hamming decode.",76,null],[13,"CyclicUnrecoverable","","Too many errors were detected when attempting a cyclic decode.",76,null],[13,"ViterbiUnrecoverable","","An ambiguous symbol or too many errors were detected when attempting convolutional decode.",76,null],[13,"UnknownNid","","An unknown or corrupted NID was encountered.",76,null],[6,"Result","","Standard result using `P25Error`.",null,null],[11,"clone","","",76,{"inputs":[{"name":"self"}],"output":{"name":"p25error"}}],[11,"fmt","","",76,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",76,{"inputs":[{"name":"self"},{"name":"p25error"}],"output":{"name":"bool"}}],[0,"message","p25","High-level data unit and message receivers.",null,null],[0,"data_unit","p25::message","General low-level receiver for all data units, covering frame synchronization up to symbol decoding.",null,null],[3,"DataUnitReceiver","p25::message::data_unit","State machine for low-level data unit reception.",null,null],[4,"ReceiverEvent","","An event seen by the low-level receiver.",null,null],[13,"Symbol","","Data or status symbol.",77,null],[13,"NetworkId","","Decoded NID information.",77,null],[11,"fmt","","",77,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Create a new `DataUnitReceiver` in the initial reception state.",78,{"inputs":[],"output":{"name":"dataunitreceiver"}}],[11,"flush_pads","","Flush any remaining padding symbols at the end of the current packet, and reenter the frame synchronization state afterwards.",78,{"inputs":[{"name":"self"}],"output":null}],[11,"resync","","Force the receiver into frame synchronization.",78,{"inputs":[{"name":"self"}],"output":null}],[11,"feed","","Feed in a baseband symbol, possibly producing a receiver event. Return `Some(Ok(event))` for any normal event, `Some(Err(err))` for any error, and `None` if no event occurred.",78,{"inputs":[{"name":"self"},{"name":"f32"}],"output":{"generics":["result"],"name":"option"}}],[11,"stats","","",78,{"inputs":[{"name":"self"}],"output":{"name":"stats"}}],[0,"nid","p25::message","Network ID (NID), Network Access Code (NAC), and Data Unit utilities.",null,null],[3,"NetworkId","p25::message::nid","NID word associated with each P25 packet.",null,null],[12,"access_code","","NAC field.",79,null],[12,"data_unit","","DUID field.",79,null],[3,"NidReceiver","","State machine that attempts to parse a stream of dibits into an NID word.",null,null],[4,"NetworkAccessCode","","\"Digital squelch\" NAC field of the NID.",null,null],[13,"Default","","Default P25 NAC.",80,null],[13,"ReceiveAny","","Allows receiver to unsquelch on any NAC (shouldn't be transmitted.)",80,null],[13,"RepeatAny","","Allows repeater to unsquelch/retransmit any NAC (shouldn't be transmitted.)",80,null],[13,"Other","","Custom NAC.",80,null],[4,"DataUnit","","Data unit of associated packet.",null,null],[13,"VoiceHeader","","Voice header packet.",81,null],[13,"VoiceSimpleTerminator","","Simple terminator packet.",81,null],[13,"VoiceLCTerminator","","Terminator packet with link control word.",81,null],[13,"VoiceLCFrameGroup","","Link control voice frame group.",81,null],[13,"VoiceCCFrameGroup","","Crypto control voice frame group.",81,null],[13,"DataPacket","","Confirmed/Unconfirmed data packet",81,null],[13,"TrunkingSignaling","","Trunking signalling packet.",81,null],[11,"clone","","",80,{"inputs":[{"name":"self"}],"output":{"name":"networkaccesscode"}}],[11,"fmt","","",80,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",80,{"inputs":[{"name":"self"},{"name":"networkaccesscode"}],"output":{"name":"bool"}}],[11,"ne","","",80,{"inputs":[{"name":"self"},{"name":"networkaccesscode"}],"output":{"name":"bool"}}],[11,"from_bits","","Parse 12 bits into a NAC.",80,{"inputs":[{"name":"u16"}],"output":{"name":"networkaccesscode"}}],[11,"to_bits","","Convert NAC to a 12-bit word.",80,{"inputs":[{"name":"self"}],"output":{"name":"u16"}}],[11,"clone","","",81,{"inputs":[{"name":"self"}],"output":{"name":"dataunit"}}],[11,"fmt","","",81,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",81,{"inputs":[{"name":"self"},{"name":"dataunit"}],"output":{"name":"bool"}}],[11,"from_bits","","Parse 4 bits into a data unit type.",81,{"inputs":[{"name":"u8"}],"output":{"generics":["dataunit"],"name":"option"}}],[11,"to_bits","","Convert data unit to 4-bit word.",81,{"inputs":[{"name":"self"}],"output":{"name":"u8"}}],[11,"clone","","",79,{"inputs":[{"name":"self"}],"output":{"name":"networkid"}}],[11,"fmt","","",79,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Create an NID word from the given NAC and data unit.",79,{"inputs":[{"name":"networkaccesscode"},{"name":"dataunit"}],"output":{"name":"networkid"}}],[11,"from_bits","","Parse NID from the given 16-bit word.",79,{"inputs":[{"name":"u16"}],"output":{"generics":["networkid"],"name":"option"}}],[11,"to_bits","","Convert NID to 16-bit representation.",79,{"inputs":[{"name":"self"}],"output":{"name":"u16"}}],[11,"encode","","Encode NID into a byte sequence.",79,null],[11,"stats","","",82,{"inputs":[{"name":"self"}],"output":{"name":"stats"}}],[11,"new","","Create a new `NidReceiver` with an empty buffer.",82,{"inputs":[],"output":{"name":"nidreceiver"}}],[11,"feed","","Feed in a data symbol, possibly producing a decoded NID. Return `Some(Ok(nid))` if an NID was successfully parsed, `Some(Err(err))` if an unrecoverable error occurred, and `None` for no event.",82,{"inputs":[{"name":"self"},{"name":"dibit"}],"output":{"generics":["result"],"name":"option"}}],[0,"receiver","p25::message","High-level receiver for receiving P25 voice, data, and trunking messages.",null,null],[3,"MessageReceiver","p25::message::receiver","State machine for high-level message reception.",null,null],[12,"recv","","Lower-level stream receiver.",83,null],[4,"MessageEvent","","Events that can occur when receiving P25 messages.",null,null],[13,"Error","","A runtime error occured.",84,null],[13,"PacketNID","","An NID at the start of a packet was decoded.",84,null],[13,"VoiceHeader","","A voice header was received.",84,null],[13,"VoiceFrame","","A voice frame was received.",84,null],[13,"LinkControl","","A link control word was decoded.",84,null],[13,"CryptoControl","","A crypto control word was decoded.",84,null],[13,"LowSpeedDataFragment","","A voice low-speed data fragment was decoded.",84,null],[13,"TrunkingControl","","A trunking signalling packet was received.",84,null],[13,"VoiceTerm","","A voice terminator link control was received.",84,null],[11,"new","","Create a new `MessageReceiver` in the initial state.",83,{"inputs":[],"output":{"name":"messagereceiver"}}],[11,"feed","","Feed in a baseband sample, possibly producing a new event or message to be handled by the given handler.",83,{"inputs":[{"name":"self"},{"name":"f32"}],"output":{"generics":["messageevent"],"name":"option"}}],[11,"stats","","",83,{"inputs":[{"name":"self"}],"output":{"name":"stats"}}],[0,"status","p25::message","Status symbol interleaving and deinterleaving.",null,null],[3,"StatusInterleaver","p25::message::status","Interleaves status symbols into a stream of dibits.",null,null],[3,"StatusDeinterleaver","","Deinterleave a P25 transmitted stream into status codes and data symbols.",null,null],[4,"StatusCode","","A P25 status symbol.",null,null],[13,"InboundIdle","","Used by a repeater when the inbound channel is idle.",85,null],[13,"InboundBusy","","Used by a repeater when the inbound channel is busy.",85,null],[13,"SubscriberRepeater","","Used when a subscriber is transmitting to a repeater.",85,null],[13,"SubscriberDirect","","Used when a subscriber is transmitting directly to another subscriber.",85,null],[4,"StreamSymbol","","A symbol in a transmitted P25 stream.",null,null],[13,"Status","","Current symbol is a status code.",86,null],[13,"Data","","Current symbol is a data dibit.",86,null],[11,"new","","Create a new `StatusInterleaver` that will interleave status symbols into the given source of data symbols, using the given initial status code.",87,{"inputs":[{"name":"t"},{"name":"statuscode"}],"output":{"name":"statusinterleaver"}}],[11,"update_status","","Update current output status to the given status code.",87,{"inputs":[{"name":"self"},{"name":"statuscode"}],"output":null}],[11,"next","","",87,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"clone","","",85,{"inputs":[{"name":"self"}],"output":{"name":"statuscode"}}],[11,"fmt","","",85,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",85,{"inputs":[{"name":"self"},{"name":"statuscode"}],"output":{"name":"bool"}}],[11,"from_dibit","","Parse a status code from the given dibit.",85,{"inputs":[{"name":"dibit"}],"output":{"name":"statuscode"}}],[11,"to_dibit","","Convert the current status code into a dibit.",85,{"inputs":[{"name":"self"}],"output":{"name":"dibit"}}],[11,"clone","","",86,{"inputs":[{"name":"self"}],"output":{"name":"streamsymbol"}}],[11,"fmt","","",86,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",86,{"inputs":[{"name":"self"},{"name":"streamsymbol"}],"output":{"name":"bool"}}],[11,"ne","","",86,{"inputs":[{"name":"self"},{"name":"streamsymbol"}],"output":{"name":"bool"}}],[11,"clone","","",88,{"inputs":[{"name":"self"}],"output":{"name":"statusdeinterleaver"}}],[11,"new","","Create a new `StatusDeinterleaver` for deinterlacing immediately after the frame sync sequence.",88,{"inputs":[],"output":{"name":"statusdeinterleaver"}}],[11,"feed","","Parse the given symbol as a status or data symbol.",88,{"inputs":[{"name":"self"},{"name":"dibit"}],"output":{"name":"streamsymbol"}}],[0,"stats","p25","Runtime statistics.",null,null],[3,"Stats","p25::stats","Records various runtime statistics.",null,null],[8,"HasStats","","Indicates that a type captures statistics.",null,null],[10,"stats","","Retrieve captured statistics.",89,{"inputs":[{"name":"self"}],"output":{"name":"stats"}}],[11,"clone","","",90,{"inputs":[{"name":"self"}],"output":{"name":"stats"}}],[11,"default","","",90,{"inputs":[],"output":{"name":"self"}}],[11,"merge","","Merge in the stats from the given object and reset the other stats back to default.",90,{"inputs":[{"name":"self"},{"name":"t"}],"output":null}],[11,"clear","","Clear all stats.",90,{"inputs":[{"name":"self"}],"output":null}],[11,"record_err","","Record the given error into the current stats.",90,{"inputs":[{"name":"self"},{"name":"p25error"}],"output":null}],[11,"record_bch","","Record BCH errors.",90,{"inputs":[{"name":"self"},{"name":"usize"}],"output":null}],[11,"record_cyclic","","Record cyclic code errors.",90,{"inputs":[{"name":"self"},{"name":"usize"}],"output":null}],[11,"record_golay_std","","Record standard Golay errors.",90,{"inputs":[{"name":"self"},{"name":"usize"}],"output":null}],[11,"record_golay_ext","","Record extended Golay errors.",90,{"inputs":[{"name":"self"},{"name":"usize"}],"output":null}],[11,"record_golay_short","","Record short Golay errors.",90,{"inputs":[{"name":"self"},{"name":"usize"}],"output":null}],[11,"record_hamming_std","","Record standard Hamming code errors.",90,{"inputs":[{"name":"self"},{"name":"usize"}],"output":null}],[11,"record_hamming_short","","Record short Hamming code errors.",90,{"inputs":[{"name":"self"},{"name":"usize"}],"output":null}],[11,"record_rs_short","","Record short Reed-Solomon code errors.",90,{"inputs":[{"name":"self"},{"name":"usize"}],"output":null}],[11,"record_rs_med","","Record medium Reed-Solomon code errors.",90,{"inputs":[{"name":"self"},{"name":"usize"}],"output":null}],[11,"record_rs_long","","Record long Reed-Solomon code errors.",90,{"inputs":[{"name":"self"},{"name":"usize"}],"output":null}],[0,"trunking","p25","Trunking control message decoding.",null,null],[0,"fields","p25::trunking","Decode various trunking-related packet fields.",null,null],[3,"ServiceOptions","p25::trunking::fields","Options that can be requested/granted by a service.",null,null],[3,"Channel","","Uniquely identifies a channel within a site.",null,null],[3,"SystemServices","","Supported services of a control channel.",null,null],[3,"ChannelParamsMap","","Maps channel identifiers (maximum 16 per control channel) to their tuning parameters.",null,null],[3,"ChannelParams","","Computes TX/RX frequencies and bandwidth for channel numbers within a site.",null,null],[12,"bandwidth","","Channel bandwidth in Hz.",91,null],[3,"SiteOptions","","Options for a P25 site.",null,null],[3,"GroupTrafficUpdate","","Updates subscribers about new or ongoing talkgroup conversations.",null,null],[3,"AdjacentSite","","Advertisement of an adjacent/nearby site within the same WACN (Wide Area Communication Network.)",null,null],[3,"ChannelParamsUpdate","","Advertisement of parameters used to calculate TX/RX frequencies within the given associated channel.",null,null],[3,"AltControlChannel","","Advertisement of one or more alternative control channels for the current site.",null,null],[3,"RfssStatusBroadcast","","Site and RFSS information of current control channel.",null,null],[3,"NetworkStatusBroadcast","","WACN (Wide Area Communication Network) and System ID information of current control channel.",null,null],[3,"UnitCallAlert","","Request for a target unit to call a source unit.",null,null],[3,"UnitCallRequest","","Signals a target unit that a unit-to-unit all has been requested.",null,null],[3,"PhoneAlert","","Alerts a unit of a call from the public phone network.",null,null],[4,"TalkGroup","","Identifies which group a message belongs to.",null,null],[13,"Nobody","","Includes nobody.",92,null],[13,"Default","","Default talkgroup when no other is selected.",92,null],[13,"Everbody","","Includes everybody.",92,null],[13,"Other","","Specific group of users.",92,null],[4,"RegResponse","","Registration response.",null,null],[13,"Accept","","Registration is accepted.",93,null],[13,"Fail","","RFSS was unable to verify registration.",93,null],[13,"Deny","","Registration isn't allowed at this location.",93,null],[13,"Refuse","","Denied temporarily, but user may retry registration.",93,null],[11,"new","","Create a new `ServiceOptions` based on the given byte.",94,{"inputs":[{"name":"u8"}],"output":{"name":"serviceoptions"}}],[11,"emergency","","Whether the service should be processed as an emergency.",94,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"protected","","Whether the channel should be encrypted.",94,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"full_duplex","","Whether the channel should be full duplex for simultaneous transmit and receive (otherwise fall back to half duplex.)",94,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"packet_switched","","Whether the service should be packet switched (otherwise fall back to circuit switched.)",94,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"prio","","Priority assigned to service, with 1 as lowest and 7 as highest.",94,{"inputs":[{"name":"self"}],"output":{"name":"u8"}}],[11,"clone","","",95,{"inputs":[{"name":"self"}],"output":{"name":"channel"}}],[11,"fmt","","",95,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",95,{"inputs":[{"name":"self"},{"name":"channel"}],"output":{"name":"bool"}}],[11,"ne","","",95,{"inputs":[{"name":"self"},{"name":"channel"}],"output":{"name":"bool"}}],[11,"new","","Create a new `Channel` from the given 16 bits.",95,null],[11,"id","","Channel ID whose parameters to use.",95,{"inputs":[{"name":"self"}],"output":{"name":"u8"}}],[11,"number","","Individual channel number within the channel.",95,{"inputs":[{"name":"self"}],"output":{"name":"u16"}}],[11,"clone","","",92,{"inputs":[{"name":"self"}],"output":{"name":"talkgroup"}}],[11,"fmt","","",92,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",92,{"inputs":[{"name":"self"},{"name":"talkgroup"}],"output":{"name":"bool"}}],[11,"ne","","",92,{"inputs":[{"name":"self"},{"name":"talkgroup"}],"output":{"name":"bool"}}],[11,"new","","Parse a talkgroup from the given 16 bit slice.",92,null],[11,"from_bits","","Parse a talkgroup from the given 16 bits.",92,{"inputs":[{"name":"u16"}],"output":{"name":"talkgroup"}}],[11,"clone","","",96,{"inputs":[{"name":"self"}],"output":{"name":"systemservices"}}],[11,"fmt","","",96,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",96,{"inputs":[{"name":"self"},{"name":"systemservices"}],"output":{"name":"bool"}}],[11,"ne","","",96,{"inputs":[{"name":"self"},{"name":"systemservices"}],"output":{"name":"bool"}}],[11,"new","","Create a new `SystemServices` from the given byte.",96,{"inputs":[{"name":"u8"}],"output":{"name":"self"}}],[11,"is_composite","","Whether channel can also operate as a traffic channel in busy conditions.",96,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"updates_only","","Whether channel only transmits updates (and doesn't accept data, voice, etc. service requests.)",96,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_backup","","Whether channel operates only as backup to a primary control channel.",96,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"has_data","","Supports data service requests.",96,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"has_voice","","Supports voice service requests.",96,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"has_registration","","Supports registration requests.",96,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"has_auth","","Supports authentication requests.",96,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"default","","",97,{"inputs":[],"output":{"name":"channelparamsmap"}}],[11,"update","","Update the map with the given channel parameters.",97,{"inputs":[{"name":"self"},{"name":"channelparamsupdate"}],"output":null}],[11,"lookup","","Try to retrieve channel parameters for the given channel ID.",97,{"inputs":[{"name":"self"},{"name":"u8"}],"output":{"generics":["channelparams"],"name":"option"}}],[11,"clone","","",91,{"inputs":[{"name":"self"}],"output":{"name":"channelparams"}}],[11,"fmt","","",91,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",91,{"inputs":[{"name":"self"},{"name":"channelparams"}],"output":{"name":"bool"}}],[11,"ne","","",91,{"inputs":[{"name":"self"},{"name":"channelparams"}],"output":{"name":"bool"}}],[11,"new","","Create a new `ChannelParams` from the given base frequency (5Hz steps), bandwidth (125Hz steps), TX offset (250kHz steps), and inter-channel spacing (125Hz steps.)",91,{"inputs":[{"name":"u32"},{"name":"u16"},{"name":"u16"},{"name":"u16"}],"output":{"name":"channelparams"}}],[11,"rx_freq","","Receive frequency for the given channel number in Hz.",91,{"inputs":[{"name":"self"},{"name":"u16"}],"output":{"name":"u32"}}],[11,"tx_freq","","Transmit frequency for the given channel number in Hz.",91,{"inputs":[{"name":"self"},{"name":"u16"}],"output":{"name":"u32"}}],[11,"new","","Create a new `SiteOptions` from the given 4-bit word.",98,{"inputs":[{"name":"u8"}],"output":{"name":"siteoptions"}}],[11,"conventional","","Whether site is \"conventional\", with no trunking.",98,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"failing","","Whether site is in a failure state.",98,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"current","","Whether this information is up-to-date (whether broadcasting site is in communication with adjacent site.)",98,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"networked","","Whether site has active network connection with RFSS controller and can communicate with other sites.",98,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"new","","Create a new `GroupTrafficUpdate` decoder from the given payload bytes.",99,null],[11,"updates","","Retrieve the set of active talkgroups included in the update along with the parameters for tuning to the traffic channel of each.",99,null],[11,"new","","Create a new `AdjacentSite` decoder from the given payload bytes.",100,null],[11,"area","","Location registration area of adjacent site, which determines whether a subscriber must update the network before roaming to the site.",100,{"inputs":[{"name":"self"}],"output":{"name":"u8"}}],[11,"opts","","Description of adjacent site.",100,{"inputs":[{"name":"self"}],"output":{"name":"siteoptions"}}],[11,"system","","System ID of adjacent site within WACN.",100,{"inputs":[{"name":"self"}],"output":{"name":"u16"}}],[11,"rfss","","RF Subsystem ID of adjacent site within the System.",100,{"inputs":[{"name":"self"}],"output":{"name":"u8"}}],[11,"site","","Site ID of adjacent site within the RFSS.",100,{"inputs":[{"name":"self"}],"output":{"name":"u8"}}],[11,"channel","","Channel information for computing TX/RX frequencies.",100,{"inputs":[{"name":"self"}],"output":{"name":"channel"}}],[11,"services","","Services supported by the adjacent site.",100,{"inputs":[{"name":"self"}],"output":{"name":"systemservices"}}],[11,"new","","Create a new `ChannelParamsUpdate` decoder from the given payload bytes.",101,null],[11,"id","","Channel ID associated with the enclosed parameters (can be up to 16 per control channel.)",101,{"inputs":[{"name":"self"}],"output":{"name":"u8"}}],[11,"params","","Parameters for the associated channel.",101,{"inputs":[{"name":"self"}],"output":{"name":"channelparams"}}],[11,"new","","Create a new `AltControlChannel` decoder from the given payload bytes.",102,null],[11,"rfss","","RF Subsystem ID of current site within System.",102,{"inputs":[{"name":"self"}],"output":{"name":"u8"}}],[11,"site","","Site ID of current site within RFSS.",102,{"inputs":[{"name":"self"}],"output":{"name":"u8"}}],[11,"alts","","Retrieve alternative sites, with each site's tuning parameters and supported services.",102,null],[11,"new","","Create a new `RfssStatusBroadcast` decoder from the given payload bytes.",103,null],[11,"area","","Location registration area of current site.",103,{"inputs":[{"name":"self"}],"output":{"name":"u8"}}],[11,"networked","","Whether the site is networked with the RFSS controller, which determines if it can communicate with other sites.",103,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"system","","System ID of current site within WACN.",103,{"inputs":[{"name":"self"}],"output":{"name":"u16"}}],[11,"rfss","","RF Subsystem ID of current site within System.",103,{"inputs":[{"name":"self"}],"output":{"name":"u8"}}],[11,"site","","Site ID of current site within RFSS.",103,{"inputs":[{"name":"self"}],"output":{"name":"u8"}}],[11,"channel","","Channel information for computing TX/RX frequencies.",103,{"inputs":[{"name":"self"}],"output":{"name":"channel"}}],[11,"services","","Services supported by the current site.",103,{"inputs":[{"name":"self"}],"output":{"name":"systemservices"}}],[11,"new","","Create a new `NetworkStatusBroadcast` decoder from the given payload bytes.",104,null],[11,"area","","Location registration area of site.",104,{"inputs":[{"name":"self"}],"output":{"name":"u8"}}],[11,"wacn","","WACN ID within the communications network.",104,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"system","","System ID of site within WACN.",104,{"inputs":[{"name":"self"}],"output":{"name":"u16"}}],[11,"channel","","Channel information for computing TX/RX frequencies.",104,{"inputs":[{"name":"self"}],"output":{"name":"channel"}}],[11,"services","","Services supported by the current site.",104,{"inputs":[{"name":"self"}],"output":{"name":"systemservices"}}],[11,"clone","","",93,{"inputs":[{"name":"self"}],"output":{"name":"regresponse"}}],[11,"eq","","",93,{"inputs":[{"name":"self"},{"name":"regresponse"}],"output":{"name":"bool"}}],[11,"fmt","","",93,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"from_bits","","Try to parse a registration response from the given 2 bits.",93,{"inputs":[{"name":"u8"}],"output":{"name":"regresponse"}}],[11,"new","","Create a new `UnitCallAlert` decoder from the given payload bytes.",105,null],[11,"dest_unit","","Target unit.",105,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"src_unit","","Requesting unit.",105,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"new","","Create a new `UnitCallRequest` decoder from the given payload bytes.",106,null],[11,"opts","","Options requested/granted for resulting channel.",106,{"inputs":[{"name":"self"}],"output":{"name":"serviceoptions"}}],[11,"dest_unit","","Target unit.",106,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"src_unit","","Requesting unit.",106,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"new","","Create a new `PhoneAlert` decoder from the given payload bytes.",107,null],[11,"digits","","The 10-digit phone number of the calling party, as encoded bytes.",107,null],[11,"dest_unit","","Unit the call is for.",107,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[0,"tsbk","p25::trunking","Receive Trunking Signalling Block (TSBK) packets and decode the various TSBK payloads.",null,null],[3,"TsbkReceiver","p25::trunking::tsbk","State machine for receiving a TSBK packet.",null,null],[3,"TsbkFields","","A Trunking Signalling Block packet.",null,null],[3,"LocRegResponse","","Response given to a location registration request.",null,null],[3,"UnitRegResponse","","Response given to an attempted user registration.",null,null],[3,"UnitDeregAck","","Acknowledgement of successful user deregistration request.",null,null],[3,"GroupVoiceGrant","","Indicates a talkgroup has been granted a voice traffic channel.",null,null],[3,"UnitTrafficChannel","","Indicates a pair of units have been granted a traffic channel.",null,null],[3,"PhoneGrant","","Indicates a unit has been granted a traffic channel for a phone call.",null,null],[3,"GroupDataGrant","","Indicates a talkgroup has been granted a data traffic channel.",null,null],[4,"TsbkOpcode","","Type of a TSBK payload.",null,null],[13,"GroupVoiceGrant","","",108,null],[13,"GroupVoiceUpdate","","",108,null],[13,"GroupVoiceUpdateExplicit","","",108,null],[13,"UnitVoiceGrant","","",108,null],[13,"UnitCallRequest","","",108,null],[13,"UnitVoiceUpdate","","",108,null],[13,"PhoneGrant","","",108,null],[13,"PhoneAlert","","",108,null],[13,"UnitDataGrant","","",108,null],[13,"GroupDataGrant","","",108,null],[13,"GroupDataUpdate","","",108,null],[13,"GroupDataUpdateExplicit","","",108,null],[13,"UnitStatusUpdate","","",108,null],[13,"UnitStatusQuery","","",108,null],[13,"UnitShortMessage","","",108,null],[13,"UnitMonitor","","",108,null],[13,"UnitCallAlert","","",108,null],[13,"AckResponse","","",108,null],[13,"QueuedResponse","","",108,null],[13,"ExtendedFunctionResponse","","",108,null],[13,"DenyResponse","","",108,null],[13,"GroupAffiliationResponse","","",108,null],[13,"GroupAffiliationQuery","","",108,null],[13,"LocRegResponse","","",108,null],[13,"UnitRegResponse","","",108,null],[13,"UnitRegCommand","","",108,null],[13,"UnitAuthCommand","","",108,null],[13,"UnitDeregAck","","",108,null],[13,"RoamingAddrCommand","","",108,null],[13,"RoamingAddrUpdate","","",108,null],[13,"SystemServiceBroadcast","","",108,null],[13,"AltControlChannel","","",108,null],[13,"RfssStatusBroadcast","","",108,null],[13,"NetworkStatusBroadcast","","",108,null],[13,"AdjacentSite","","",108,null],[13,"ChannelParamsUpdate","","",108,null],[13,"ProtectionParamBroadcast","","",108,null],[13,"ProtectionParamUpdate","","",108,null],[13,"Reserved","","",108,null],[6,"Buf","","Buffer of bytes that represents a TSBK packet.",null,null],[11,"new","","Create a new `TsbkReceiver` in the initial state.",109,{"inputs":[],"output":{"name":"tsbkreceiver"}}],[11,"feed","","Feed in a baseband symbol, possibly producing a complete TSBK packet. Return `Some(Ok(pkt))` if a packet was successfully received, `Some(Err(err))` if an error occurred, and `None` in the case of no event.",109,{"inputs":[{"name":"self"},{"name":"dibit"}],"output":{"generics":["result"],"name":"option"}}],[11,"clone","","",108,{"inputs":[{"name":"self"}],"output":{"name":"tsbkopcode"}}],[11,"fmt","","",108,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",108,{"inputs":[{"name":"self"},{"name":"tsbkopcode"}],"output":{"name":"bool"}}],[11,"from_bits","","Try to parse an opcode from the given 6 bits.",108,{"inputs":[{"name":"u8"}],"output":{"generics":["tsbkopcode"],"name":"option"}}],[11,"clone","","",110,{"inputs":[{"name":"self"}],"output":{"name":"tsbkfields"}}],[11,"new","","Interpret the given bytes as a TSBK packet.",110,{"inputs":[{"name":"buf"}],"output":{"name":"tsbkfields"}}],[11,"is_tail","","Whether this packet is the last one in the TSBK group.",110,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"protected","","Whether the packet is encrypted.",110,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"opcode","","Type of data contained in the payload.",110,{"inputs":[{"name":"self"}],"output":{"generics":["tsbkopcode"],"name":"option"}}],[11,"mfg","","Manufacturer ID, which determines if the packet is standardized.",110,{"inputs":[{"name":"self"}],"output":{"name":"u8"}}],[11,"crc","","Transmitted CRC.",110,{"inputs":[{"name":"self"}],"output":{"name":"u16"}}],[11,"calc_crc","","Calculate 16-bit CRC over bytes in packet.",110,{"inputs":[{"name":"self"}],"output":{"name":"u16"}}],[11,"crc_valid","","Verify if the calculated CRC matches the transmitted one.",110,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"payload","","Bytes that make up the payload of the packet.",110,null],[11,"new","","Create a new `LocRegResponse` decoder from the base TSBK decoder.",111,{"inputs":[{"name":"tsbkfields"}],"output":{"name":"self"}}],[11,"response","","System response to the registration request.",111,{"inputs":[{"name":"self"}],"output":{"name":"regresponse"}}],[11,"talkgroup","","Talkgroup of requesting unit.",111,{"inputs":[{"name":"self"}],"output":{"name":"talkgroup"}}],[11,"rfss","","RF Subsystem ID of site within System.",111,{"inputs":[{"name":"self"}],"output":{"name":"u8"}}],[11,"site","","Site ID of site within RFSS.",111,{"inputs":[{"name":"self"}],"output":{"name":"u8"}}],[11,"dest_unit","","Address of requesting unit.",111,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"new","","Create a new `UnitRegResponse` decoder from the base TSBK decoder.",112,{"inputs":[{"name":"tsbkfields"}],"output":{"name":"self"}}],[11,"response","","System response to user registration request.",112,{"inputs":[{"name":"self"}],"output":{"name":"regresponse"}}],[11,"system","","System ID within WACN.",112,{"inputs":[{"name":"self"}],"output":{"name":"u16"}}],[11,"src_id","","Address of originating unit, which uniquely identifies the unit within the System.",112,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"src_addr","","ID of originating unit which, along with the WACN and System ID, uniquely identifies the unit.",112,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"new","","Create a new `UnitDeregAck` decoder from the base TSBK decoder.",113,{"inputs":[{"name":"tsbkfields"}],"output":{"name":"self"}}],[11,"wacn","","WACN ID within the communication network.",113,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"system","","System ID within WACN.",113,{"inputs":[{"name":"self"}],"output":{"name":"u16"}}],[11,"src_unit","","ID of affected unit.",113,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"new","","Create a new `GroupVoiceGrant` decoder from the base TSBK decoder.",114,{"inputs":[{"name":"tsbkfields"}],"output":{"name":"self"}}],[11,"opts","","Options requested/granted for the traffic channel.",114,{"inputs":[{"name":"self"}],"output":{"name":"serviceoptions"}}],[11,"channel","","Parameters for tuning to the traffic channel.",114,{"inputs":[{"name":"self"}],"output":{"name":"channel"}}],[11,"talkgroup","","Talkgroup for the conversation.",114,{"inputs":[{"name":"self"}],"output":{"name":"talkgroup"}}],[11,"src_unit","","Unit that initiated the conversation.",114,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"new","","Create a new `UnitTrafficChannel` decoder from the base TSBK decoder.",115,{"inputs":[{"name":"tsbkfields"}],"output":{"name":"self"}}],[11,"channel","","Parameters for tuning to the traffic channel.",115,{"inputs":[{"name":"self"}],"output":{"name":"channel"}}],[11,"dest_unit","","Destination unit of the call.",115,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"src_unit","","Originating unit of the call.",115,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"new","","Create a new `PhoneGrant` decoder from the base TSBK decoder.",116,{"inputs":[{"name":"tsbkfields"}],"output":{"name":"self"}}],[11,"opts","","Options requested/granted for the traffic channel.",116,{"inputs":[{"name":"self"}],"output":{"name":"serviceoptions"}}],[11,"channel","","Parameters for tuning to the traffic channel.",116,{"inputs":[{"name":"self"}],"output":{"name":"channel"}}],[11,"call_timer","","Maximum amount of time (in units of 100ms) that the phone call can occupy the traffic channel.",116,{"inputs":[{"name":"self"}],"output":{"name":"u16"}}],[11,"unit","","Unit assigned to the call.",116,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"new","","Create a new `GroupDataGrant` decoder from the base TSBK decoder.",117,{"inputs":[{"name":"tsbkfields"}],"output":{"name":"self"}}],[11,"opts","","Options requested/granted for the traffic channel.",117,{"inputs":[{"name":"self"}],"output":{"name":"serviceoptions"}}],[11,"channel","","Parameters for tuning to the traffic channel.",117,{"inputs":[{"name":"self"}],"output":{"name":"channel"}}],[11,"talkgroup","","Talkgroup assigned to the channel.",117,{"inputs":[{"name":"self"}],"output":{"name":"talkgroup"}}],[11,"src_unit","","Originating unit for the data traffic.",117,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[0,"voice","p25","Receive and decode voice-related data units.",null,null],[0,"control","p25::voice","Decode Link Control (LC) packets and payloads.",null,null],[3,"LinkControlFields","p25::voice::control","Base link control decoder, common to all packets.",null,null],[3,"GroupVoiceTraffic","","Identity of unit transmitting on the current talkgroup traffic channel.",null,null],[3,"UnitVoiceTraffic","","Identity of units transmitting on current unit-to-unit traffic channel.",null,null],[3,"PhoneTraffic","","Identity of unit participating in current phone call.",null,null],[4,"LinkControlOpcode","","Type of a link control payload.",null,null],[13,"GroupVoiceTraffic","","",118,null],[13,"GroupVoiceUpdate","","",118,null],[13,"UnitVoiceTraffic","","",118,null],[13,"GroupVoiceUpdateExplicit","","",118,null],[13,"UnitCallRequest","","",118,null],[13,"PhoneTraffic","","",118,null],[13,"PhoneAlert","","",118,null],[13,"CallTermination","","",118,null],[13,"GroupAffiliationQuery","","",118,null],[13,"UnitRegistrationRequest","","",118,null],[13,"UnitAuthenticationRequst","","",118,null],[13,"UnitStatusRequest","","",118,null],[13,"SystemServiceBroadcast","","",118,null],[13,"AltControlChannel","","",118,null],[13,"AdjacentSite","","",118,null],[13,"RfssStatusBroadcast","","",118,null],[13,"NetworkStatusBroadcast","","",118,null],[13,"UnitStatusUpdate","","",118,null],[13,"UnitShortMessage","","",118,null],[13,"UnitCallAlert","","",118,null],[13,"ExtendedFunction","","",118,null],[13,"ChannelParamsUpdate","","",118,null],[13,"ProtectionParamBroadcast","","",118,null],[13,"AltControlChannelExplicit","","",118,null],[13,"AdjacentSiteExplicit","","",118,null],[13,"ChannelParamsExplicit","","",118,null],[13,"RfssStatusExplicit","","",118,null],[13,"NetworkStatusExplicit","","",118,null],[6,"Buf","","Buffer of bytes that represents a link control packet.",null,null],[11,"clone","","",118,{"inputs":[{"name":"self"}],"output":{"name":"linkcontrolopcode"}}],[11,"fmt","","",118,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",118,{"inputs":[{"name":"self"},{"name":"linkcontrolopcode"}],"output":{"name":"bool"}}],[11,"from_bits","","Try to parse an opcode from the given 6 bits.",118,{"inputs":[{"name":"u8"}],"output":{"generics":["linkcontrolopcode"],"name":"option"}}],[11,"clone","","",119,{"inputs":[{"name":"self"}],"output":{"name":"linkcontrolfields"}}],[11,"new","","Interpret the given bytes as a link control packet.",119,{"inputs":[{"name":"buf"}],"output":{"name":"self"}}],[11,"protected","","Whether the packet is encrypted.",119,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"opcode","","Type of data contained in the payload.",119,{"inputs":[{"name":"self"}],"output":{"generics":["linkcontrolopcode"],"name":"option"}}],[11,"payload","","Bytes that make up the payload.",119,null],[11,"new","","Create a new `GroupVoiceTraffic` from the base LC decoder.",120,{"inputs":[{"name":"linkcontrolfields"}],"output":{"name":"self"}}],[11,"mfg","","Manufacturer ID of current packet.",120,{"inputs":[{"name":"self"}],"output":{"name":"u8"}}],[11,"opts","","Service options provided by current traffic channel.",120,{"inputs":[{"name":"self"}],"output":{"name":"serviceoptions"}}],[11,"talkgroup","","Current resident talkgroup of traffic channel.",120,{"inputs":[{"name":"self"}],"output":{"name":"talkgroup"}}],[11,"src_unit","","Address of user currently transmitting.",120,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"new","","Create a new `UnitVoiceTraffic` from the base LC decoder.",121,{"inputs":[{"name":"linkcontrolfields"}],"output":{"name":"self"}}],[11,"mfg","","Manufacturer ID of current packet.",121,{"inputs":[{"name":"self"}],"output":{"name":"u8"}}],[11,"opts","","Service options provided by current traffic channel.",121,{"inputs":[{"name":"self"}],"output":{"name":"serviceoptions"}}],[11,"dest_unit","","Destination user address for current transmission.",121,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"src_unit","","Source user address for current transmission.",121,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"new","","Create a new `PhoneTraffic` decoder from the base LC decoder.",122,{"inputs":[{"name":"linkcontrolfields"}],"output":{"name":"self"}}],[11,"opts","","Options requested/granted for the traffic channel.",122,{"inputs":[{"name":"self"}],"output":{"name":"serviceoptions"}}],[11,"call_timer","","Maximum amount of time (in units of 100ms) that the phone call can occupy the traffic channel.",122,{"inputs":[{"name":"self"}],"output":{"name":"u16"}}],[11,"unit","","Unit participating in call.",122,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[0,"crypto","p25::voice","Decode Cryptographic Control (CC) packets.",null,null],[3,"CryptoControlFields","p25::voice::crypto","Information necessary to decrypt an encrypted message.",null,null],[4,"CryptoAlgorithm","","Type of cryptographic algorithm.",null,null],[13,"Accordion","","",123,null],[13,"BatonEven","","",123,null],[13,"Firefly","","",123,null],[13,"Mayfly","","",123,null],[13,"Saville","","",123,null],[13,"BatonOdd","","",123,null],[13,"Unencrypted","","",123,null],[13,"Des","","",123,null],[13,"TripleDes","","",123,null],[13,"Aes","","",123,null],[13,"Other","","",123,null],[6,"Buf","","Buffer of bytes that represent a crypto control packet.",null,null],[11,"new","","Create a new `CryptoControlFields` decoder from the given bytes.",124,{"inputs":[{"name":"buf"}],"output":{"name":"self"}}],[11,"init","","Initialization vector used internally by associated crypto algorithm.",124,null],[11,"alg","","Type of crypto algorithm in use, if any.",124,{"inputs":[{"name":"self"}],"output":{"name":"cryptoalgorithm"}}],[11,"key","","Encryption key to use.",124,{"inputs":[{"name":"self"}],"output":{"name":"u16"}}],[11,"clone","","",123,{"inputs":[{"name":"self"}],"output":{"name":"cryptoalgorithm"}}],[11,"fmt","","",123,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",123,{"inputs":[{"name":"self"},{"name":"cryptoalgorithm"}],"output":{"name":"bool"}}],[11,"ne","","",123,{"inputs":[{"name":"self"},{"name":"cryptoalgorithm"}],"output":{"name":"bool"}}],[11,"from_bits","","Parse the given 8 bits into a crypto algorithm.",123,{"inputs":[{"name":"u8"}],"output":{"name":"cryptoalgorithm"}}],[0,"descramble","p25::voice","Descramble/Deinterleave the dibits in a received voice frame.",null,null],[5,"descramble","p25::voice::descramble","Descramble a portion of the given voice frame dibits into the PN-scrambled, coded chunk `u_{idx}`.",null,null],[0,"frame","p25::voice","Decode a voice frame into chunks suitable for IMBE.",null,null],[3,"VoiceFrame","p25::voice::frame","IMBE-encoded voice frame.",null,null],[12,"chunks","","Chunks of IMBE-prioritized data, Known as `u_0`, ..., `u_7` in the standard.",125,null],[12,"errors","","Number of FEC errors detected for each associated chunk `u_0`, ..., `u_6`.",125,null],[11,"new","","Try to decode a `VoiceFrame` from the given coded, PN-scrambled, interleaved dibits. Return `Ok(frame)` if the frame was successfully decoded, and `Err(err)` otherwise.",125,null],[0,"frame_group","p25::voice","Receive voice frame groups, known as LDU1 and LDU2 in the standard.",null,null],[3,"FrameGroupReceiver","p25::voice::frame_group","State machine that receives the various pieces that make up a frame group.",null,null],[3,"LinkControlExtra","","Link control frame group extra.",null,null],[3,"CryptoControlExtra","","Crypto control frame group extra.",null,null],[4,"FrameGroupEvent","","Events that can occur when receiving a frame group.",null,null],[13,"VoiceFrame","","Decoded a voice frame.",126,null],[13,"Extra","","Decoded an \"extra\" packet.",126,null],[13,"DataFragment","","Decoded a 16-bit fragment of the low-speed data word.",126,null],[6,"VoiceLCFrameGroupReceiver","","Receiver for Link Control (LC) frame group.",null,null],[6,"VoiceCCFrameGroupReceiver","","Receiver for Crypto Control (CC) frame group.",null,null],[8,"Extra","","An \"extra\" information packet carried along in a frame group.",null,null],[16,"Fields","","Base decoder for the packet.",127,null],[10,"decode_rs","","Decode the inner Reed Soloman code.",127,null],[10,"decode_extra","","Transform the given hexbits into a base packet decoder.",127,null],[11,"new","","Create a new `FrameGroupReceiver` in the initial state.",128,{"inputs":[],"output":{"name":"framegroupreceiver"}}],[11,"done","","Whether the full frame group has been received.",128,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"feed","","Feed in a baseband symbol, possibly producing an event. Return `Some(Ok(event))` if a nominal event occurred, `Some(Err(err))` if an error occurred, and `None` in the case of no event.",128,{"inputs":[{"name":"self"},{"name":"dibit"}],"output":{"generics":["result"],"name":"option"}}],[11,"stats","","",128,{"inputs":[{"name":"self"}],"output":{"name":"stats"}}],[11,"decode_rs","","",129,null],[11,"decode_extra","","",129,null],[11,"decode_rs","","",130,null],[11,"decode_extra","","",130,null],[0,"header","p25::voice","Receive and decode voice header packets.",null,null],[3,"VoiceHeaderReceiver","p25::voice::header","State machine for receiving a voice header packet.",null,null],[3,"VoiceHeaderFields","","Begins each voice message with information necessary to decode the following superframes.",null,null],[6,"Buf","","Buffer of bytes that represents a voice header packet.",null,null],[11,"stats","","",131,{"inputs":[{"name":"self"}],"output":{"name":"stats"}}],[11,"new","","Create a new `VoiceHeaderReceiver` in the initial state.",131,{"inputs":[],"output":{"name":"voiceheaderreceiver"}}],[11,"feed","","Feed in a baseband symbol, possibly producing a voice header packet. Return `Some(Ok(pkt))` if the packet was successfully received, `Some(Err(err))` if an error occurred, and `None` in the case of no event.",131,{"inputs":[{"name":"self"},{"name":"dibit"}],"output":{"generics":["result"],"name":"option"}}],[11,"new","","Create a new `VoiceHeaderFields` decoder from the given bytes.",132,{"inputs":[{"name":"buf"}],"output":{"name":"self"}}],[11,"crypto_init","","Initialization vector for cryptographic algorithm.",132,null],[11,"mfg","","Manufacturer ID.",132,{"inputs":[{"name":"self"}],"output":{"name":"u8"}}],[11,"crypto_alg","","Cryptographic algorithm in use, if any.",132,{"inputs":[{"name":"self"}],"output":{"name":"cryptoalgorithm"}}],[11,"crypto_key","","Encryption key to use.",132,{"inputs":[{"name":"self"}],"output":{"name":"u16"}}],[11,"talk_group","","Talkgroup participating in the voice message.",132,{"inputs":[{"name":"self"}],"output":{"name":"talkgroup"}}],[0,"rand","p25::voice","Pseudo-random (PN) sequence used for voice frame scrambling/descrambling.",null,null],[3,"PseudoRand","p25::voice::rand","Generates 23-bit and 15-bit scrambling words using the P25 PN sequence algorithm.",null,null],[11,"new","","Create a new `PseudoRand` generator using the given 12-bit seed.",133,{"inputs":[{"name":"u16"}],"output":{"name":"pseudorand"}}],[11,"next_23","","Retrieve the next 23-bit scrambling word.",133,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"next_15","","Retrieve the next 15-bit scrambling word.",133,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[0,"term","p25::voice","Decode voice Link Control (LC) terminator packets.",null,null],[3,"VoiceLCTerminatorReceiver","p25::voice::term","State machine for receiving a link control voice terminator.",null,null],[11,"new","","Create a new `VoiceLCTerminatorReceiver` in the initial state.",134,{"inputs":[],"output":{"name":"voicelcterminatorreceiver"}}],[11,"feed","","Feed in a baseband symbol, possibly producing a link control packet. Return `Some(Ok(lc))` if an LC packet was successfully recovered from the terminator, `Some(Err(err))` if an error occurred, and `None` in the case of no event.",134,{"inputs":[{"name":"self"},{"name":"dibit"}],"output":{"generics":["result"],"name":"option"}}],[11,"stats","","",134,{"inputs":[{"name":"self"}],"output":{"name":"stats"}}]],"paths":[[3,"Decoder"],[3,"Decider"],[3,"C4fmImpulses"],[3,"C4fmDeviationDibits"],[3,"SyncCorrelator"],[3,"SymbolThresholds"],[3,"SyncDetector"],[3,"SyncFingerprint"],[8,"IterParams"],[3,"Dibit"],[3,"DibitParams"],[3,"Tribit"],[3,"TribitParams"],[3,"Hexbit"],[3,"HexbitParams"],[3,"DibitByteParams"],[3,"TribitByteParams"],[3,"HexbitByteParams"],[3,"SubByteIter"],[8,"GaloisField"],[8,"PolynomialCoefs"],[3,"P25Field"],[3,"Codeword"],[3,"Polynomial"],[3,"ErrorLocator"],[3,"PolynomialRoots"],[3,"ErrorDescriptions"],[3,"Errors"],[3,"Walk"],[8,"States"],[8,"WalkHistory"],[8,"Walks"],[3,"DibitStates"],[3,"TribitStates"],[3,"TrellisFSM"],[3,"DibitHistory"],[3,"TribitHistory"],[3,"DibitWalks"],[3,"TribitWalks"],[3,"ViterbiDecoder"],[3,"DataCoder"],[6,"DibitCoder"],[6,"TribitCoder"],[8,"CRCParams"],[3,"CRC9Params"],[3,"CRC16Params"],[3,"CRC32Params"],[3,"CRC"],[4,"DataPacketOpcode"],[4,"ServiceAccessPoint"],[3,"Fragments"],[3,"HeaderPreamble"],[3,"ServiceAccessPoint"],[3,"Manufacturer"],[3,"LogicalLink"],[3,"BlockCount"],[3,"PadCount"],[3,"Sequencing"],[3,"DataOffset"],[3,"ConfirmedFields"],[3,"UnconfirmedFields"],[8,"BufWrite"],[8,"ByteField"],[3,"ConfirmedPreamble"],[3,"UnconfirmedPreamble"],[3,"Header"],[3,"Interleaver"],[3,"Deinterleaver"],[8,"PacketParams"],[3,"ConfirmedParams"],[3,"UnconfirmedParams"],[3,"Payload"],[3,"PayloadIter"],[3,"PayloadBlock"],[3,"TailBlock"],[3,"ConfirmedBlockHeader"],[4,"P25Error"],[4,"ReceiverEvent"],[3,"DataUnitReceiver"],[3,"NetworkId"],[4,"NetworkAccessCode"],[4,"DataUnit"],[3,"NidReceiver"],[3,"MessageReceiver"],[4,"MessageEvent"],[4,"StatusCode"],[4,"StreamSymbol"],[3,"StatusInterleaver"],[3,"StatusDeinterleaver"],[8,"HasStats"],[3,"Stats"],[3,"ChannelParams"],[4,"TalkGroup"],[4,"RegResponse"],[3,"ServiceOptions"],[3,"Channel"],[3,"SystemServices"],[3,"ChannelParamsMap"],[3,"SiteOptions"],[3,"GroupTrafficUpdate"],[3,"AdjacentSite"],[3,"ChannelParamsUpdate"],[3,"AltControlChannel"],[3,"RfssStatusBroadcast"],[3,"NetworkStatusBroadcast"],[3,"UnitCallAlert"],[3,"UnitCallRequest"],[3,"PhoneAlert"],[4,"TsbkOpcode"],[3,"TsbkReceiver"],[3,"TsbkFields"],[3,"LocRegResponse"],[3,"UnitRegResponse"],[3,"UnitDeregAck"],[3,"GroupVoiceGrant"],[3,"UnitTrafficChannel"],[3,"PhoneGrant"],[3,"GroupDataGrant"],[4,"LinkControlOpcode"],[3,"LinkControlFields"],[3,"GroupVoiceTraffic"],[3,"UnitVoiceTraffic"],[3,"PhoneTraffic"],[4,"CryptoAlgorithm"],[3,"CryptoControlFields"],[3,"VoiceFrame"],[4,"FrameGroupEvent"],[8,"Extra"],[3,"FrameGroupReceiver"],[3,"LinkControlExtra"],[3,"CryptoControlExtra"],[3,"VoiceHeaderReceiver"],[3,"VoiceHeaderFields"],[3,"PseudoRand"],[3,"VoiceLCTerminatorReceiver"]]};
searchIndex["rtlsdr"] = {"doc":"This crate provides a high-level interface to the RTL-SDR that separates controlling the device and reading samples, for integration into multithreaded applications.","items":[[3,"Controller","rtlsdr","Controls hardware parameters.",null,null],[3,"Reader","","Reads I/Q samples.",null,null],[5,"devices","","Create an iterator over available RTL-SDR devices.",null,null],[5,"open","","Try to open the RTL-SDR device at the given index.",null,{"inputs":[{"name":"u32"}],"output":{"name":"result"}}],[6,"TunerGains","","Holds a list of valid gain values.",null,null],[6,"Error","","Error type for this crate.",null,null],[6,"Result","","Result type for this crate.",null,null],[11,"sample_rate","","Get the current sample rate (megasamples/sec).",0,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"set_sample_rate","","Set the sample rate (megasamples/sec).",0,{"inputs":[{"name":"self"},{"name":"u32"}],"output":{"name":"result"}}],[11,"center_freq","","Get the current center frequency (Hz).",0,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"set_center_freq","","Set the center frequency (Hz).",0,{"inputs":[{"name":"self"},{"name":"u32"}],"output":{"name":"result"}}],[11,"ppm","","Get the current frequency correction (ppm).",0,{"inputs":[{"name":"self"}],"output":{"name":"i32"}}],[11,"set_ppm","","Set the frequency correction (ppm).",0,{"inputs":[{"name":"self"},{"name":"i32"}],"output":{"name":"result"}}],[11,"enable_agc","","Enable the hardware AGC.",0,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"disable_agc","","Disable the hardware AGC.",0,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"tuner_gains","","Get the list of valid tuner gain values.",0,null],[11,"tuner_gain","","Get the current tuner gain in the same format as that returned by `tuner_gains()`.",0,{"inputs":[{"name":"self"}],"output":{"name":"i32"}}],[11,"set_tuner_gain","","Set the tuner gain in the same format as that returned by `tuner_gains()`.",0,{"inputs":[{"name":"self"},{"name":"i32"}],"output":{"name":"result"}}],[11,"cancel_async_read","","Cancel an asynchronous read if one is running.",0,{"inputs":[{"name":"self"}],"output":null}],[11,"read_async","","Begin reading I/Q samples, buffering into the given number of chunks, with each chunk holding the given number of bytes. The given callback is called whenever new samples are available, receiving a chunk at a time.",1,{"inputs":[{"name":"self"},{"name":"u32"},{"name":"u32"},{"name":"f"}],"output":{"name":"result"}}]],"paths":[[3,"Controller"],[3,"Reader"]]};
searchIndex["rtlsdr_sys"] = {"doc":"This crate provides low-level FFI bindings for librtlsdr. See the `rtl-sdr.h` header distributed with the library for a description of each corresponding binding.","items":[[4,"rtlsdr_tuner","rtlsdr_sys","",null,null],[13,"RTLSDR_TUNER_UNKNOWN","","",0,null],[13,"RTLSDR_TUNER_E4000","","",0,null],[13,"RTLSDR_TUNER_FC0012","","",0,null],[13,"RTLSDR_TUNER_FC0013","","",0,null],[13,"RTLSDR_TUNER_FC2580","","",0,null],[13,"RTLSDR_TUNER_R820T","","",0,null],[13,"RTLSDR_TUNER_R828D","","",0,null],[5,"rtlsdr_get_device_count","","",null,null],[5,"rtlsdr_get_device_name","","",null,null],[5,"rtlsdr_get_device_usb_strings","","",null,null],[5,"rtlsdr_get_index_by_serial","","",null,null],[5,"rtlsdr_open","","",null,null],[5,"rtlsdr_close","","",null,null],[5,"rtlsdr_set_xtal_freq","","",null,null],[5,"rtlsdr_get_xtal_freq","","",null,null],[5,"rtlsdr_get_usb_strings","","",null,null],[5,"rtlsdr_write_eeprom","","",null,null],[5,"rtlsdr_read_eeprom","","",null,null],[5,"rtlsdr_set_center_freq","","",null,null],[5,"rtlsdr_get_center_freq","","",null,null],[5,"rtlsdr_set_freq_correction","","",null,null],[5,"rtlsdr_get_freq_correction","","",null,null],[5,"rtlsdr_get_tuner_type","","",null,null],[5,"rtlsdr_get_tuner_gains","","",null,null],[5,"rtlsdr_set_tuner_gain","","",null,null],[5,"rtlsdr_get_tuner_gain","","",null,null],[5,"rtlsdr_set_tuner_bandwidth","","",null,null],[5,"rtlsdr_set_tuner_if_gain","","",null,null],[5,"rtlsdr_set_tuner_gain_mode","","",null,null],[5,"rtlsdr_set_sample_rate","","",null,null],[5,"rtlsdr_get_sample_rate","","",null,null],[5,"rtlsdr_set_testmode","","",null,null],[5,"rtlsdr_set_agc_mode","","",null,null],[5,"rtlsdr_set_direct_sampling","","",null,null],[5,"rtlsdr_get_direct_sampling","","",null,null],[5,"rtlsdr_set_offset_tuning","","",null,null],[5,"rtlsdr_get_offset_tuning","","",null,null],[5,"rtlsdr_reset_buffer","","",null,null],[5,"rtlsdr_read_sync","","",null,null],[5,"rtlsdr_read_async","","",null,null],[5,"rtlsdr_cancel_async","","",null,null],[6,"rtlsdr_dev_t","","",null,null],[6,"rtlsdr_read_async_cb_t","","",null,null]],"paths":[[4,"rtlsdr_tuner"]]};
initSearch(searchIndex);
